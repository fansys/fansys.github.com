{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"数据结构 - 最小栈","text":"本文讲述怎么去实现一个栈，并且入栈、出栈、获取最小值的时间复杂度都是 O(1) 栈的实现栈可以使用数组或链表结构实现，在 Java 中的 Stack 类的实现使用的数组结构 一个元素数组 一个记录元素总数的变量当入栈时，设置 elementCount 索引位置的值为入栈元素值，elementCount++当出栈时，获取 elementCount - 1 索引位置元素的值，elementCount– 最小栈的实现方法1定义一个变量 min，每次入栈时与 min 比较大小，当小于 min 时，将值赋值给 min这个方法入栈时，能保证 getMin() 获取的值为最小值，但是如果最小值出栈，则无法知道下一个最小的元素 方法2定义一个辅助栈，入栈时将当前最小值入辅助栈推论1：当栈为空时，第一个入辅助栈的元素必定为栈底元素，可以保证辅助栈在栈不为空时始终有元素推论2：因为每次将最小的元素入辅助栈，所以辅助栈中最小的元素出栈后，栈顶的元素也必定是当前最小的推论3：如果有两个最小元素值相同，如果辅助栈只入栈第一个元素，那么当第二个元素出栈后获取新的栈顶元素不再是最小值，因此相同的最小元素也要入栈 代码实现 123456789101112131415161718192021private Stack&lt;Integer&gt; mainStack = new Stack&lt;&gt;();private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();public void push(int element) { mainStack.push(element); if (minStack.isEmpty() || element &lt;= minStack.peek()) { minStack.push(element); }}public int pop() { int element = mainStack.pop(); if (element.equals(minStack.peek())) { minStack.pop(); } return element;}public int getMin() { return minStack.peek();}","link":"/2020/11/05/datastruct-min-stack/"},{"title":"JVM 垃圾收集","text":"本文主要介绍 Java 堆的垃圾收集策略和一些常见的垃圾收集器 新生代垃圾收集新生代的垃圾回收一般采用复制算法，回收的过程如下： 将 Eden 和 S0 中存活的对象复制到 S1 中，对象年龄+1，当对象年龄到达阈值（默认: 15）时，对象将晋升到老年代 清空 Eden 内存区域，交换 S0 和 S1 区域 如果 S1 区域存放不下则使用分配担保机制直接进入老年代 对象晋升老年代的阈值可以通过 -XX:MaxTenuringThreshold 设置 老年代垃圾收集Minor GC 和 Full GC 新生代GC (Minor GC): 新生代发生的 GC，Minor GC 非常频繁，速度也比较快 老年代GC (Major GC / Full GC): 老年代的 GC，通常伴有至少一次 Minor GC （并非绝对），回收时间是 Minor GC 的10倍以上 垃圾回收算法 复制算法：将内存分为大小相同的两块，每次将存活的对象复制到另一块，再把使用的空间一次清理掉 标记-清除：先标记需要回收的对象，标记完成后一次清理掉需要回收的对象，会产生内存碎片 标记-整理：先标记需要回收的对象，再将存活对象向一端移动，完成后清除端边界以外的内存 垃圾收集器常见的垃圾收集器有： Serial, ParNew, Parallel Scavenge,CMS、G1 Serial使用单线程收集，新生代使用复制算法，老年代使用标记整理 ParNew使用多线程收集，其余和 Serial 一样，新生代使用复制算法，老年代使用标记整理 Parallel Scavenge关注吞吐量，可以通过一些参数指定需要优化的目标，垃圾收集器能自动优化-XX:MaxGCPauseMillis 最大暂停时间, 0以上/毫秒-XX:GCTimeRatio GC时间占总时间的比例, 0-100-XX:+UseAdptiveSizePolicy 根据性能监控信息，动态调整参数 Serial OldSerial 收集器的老年代版本，可作为 CMS 的后备收集器 Parallel OldParallel Scavenge 收集器的老年代版本，可作为 CMS 的后备收集器 CMSCMS（Concurrent Mark Sweep）是以获得最短停顿时间为目标的收集器优点：并发收集，停顿时间短缺点：会产生内存碎片，因此需要使用 Serial Old 或 Parallel Old 作为后备收集器 CMS 是一种用 标记-清除 算法的实现，分为四个步骤 初始标记：暂停所有线程，并记录与 GC Roots 直接相连的对象，很快并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象，同时记录用户线程更新的引用域重新标记：暂停用户线程，修正并发标记期间因为用户线程运行而导致标记产生变动的那一部分对象的标记记录，时间比初始标记长，远远比并发标记短并发清除：同时开启用户线程，对标记区域进行清除 G1Heap 被划分为一个个大小相等的不连续的内存区域(Region)每个 Region 都有一个分代角色: Eden, Survior, Old（old还有一种细分 humongous，用来存放大小超过 region 50%以上的巨型对象）每个 Region 的角色可以变更每个角色的数量没有强制的限定，默认年轻代占5% G1优先去执行大量对象可被回收的 Region，使用暂停可预测决定一次回收多少 RegionG1从多个 Region 中复制存活对象到1个 Region，同时整理-清除内存 TODO 待补充 如何判断对象可被回收？算法 引用计数给对象分配一个计数器，当被引用时计数器+1，使用完后计数器-1，当计数器为0时，对象不可能被引用 可达性分析可达性分析是从 GC Roots 往下搜索，当对象未被任一 GC Root 链引用到时，则证明对象不可用可被回收 GC Root可以作为 GC Roots 的对象 由 系统类加载器 (System Class Loader) 加载的对象 Thread - 活着的线程 Stack Local - Java 方法的local变量或参数 JNI Local - JNI 方法的local变量或参数 JNI Global - 全局 JNI 引用 Monitor Used - 用于同步的监控对象 Held by JVM - 由JVM GC 保留的对象 强引用、软引用、弱引用、虚引用 强引用：直接引用的对象 软引用：可有可无的对象，当内存不足时，会被回收 弱引用：可有可无的对象，生命周期比弱引用短，当发生GC是会被回收 虚引用：任何时候都可能被回收，主要用来跟踪对象被垃圾回收的过程","link":"/2020/11/04/java-garbage-collection/"},{"title":"贪心算法","text":"贪心算法：依次求局部最优解，最终得到整体最优解的思想 本文内容包含了几个常见的贪心算法问题 一个整数删除 k 个数字后的最小值 一个整数删除 k 个数字后的最小值对于这个问题，需要考虑怎么确定 k 个数字的位置 思路1: 删除最大的几个数字 在一些情况下，这个思路可行，如: 54321(删除2个), 75310(删除2个)但是在很多非递增的情况，不可行，如：52130，删除5,3后的值为210，并不是最小值130 思路2: 每次删除1个数字，删除k次 这个思路将删除 k 个数字变换成求删除1个数字的最小值计算局部的最优解，最终得到整体的最优解 对于思路2，使用的既是贪心算法的思想，有局部最优解得到整体最优解那么，怎么确定需要删除的1个数字呢？ 对于数字序列 5,4: 删除 5 能得到最小值 对于数字序列 5,6: 删除 6 能得到最小值可以发现当序列为顺序时，删除前面的数字能得到最小值，当序列为倒序时，删除后面的数字能得到最小值 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution { public String minValue(String num, int k) { for (int i = 0; i &lt; k; i++) { // 标记是否分隔字符串 boolean cut = false; for (int j = 1; j &lt; num.length(); j++) { // 倒序，删除前面的数字 if (num.charAt(j - 1) &gt; num.charAt(j)) { num = num.substring(0, j - 1) + num.substring(j); cut = true; break; } } // 未找到倒序，删除最后一个数字 if (!cut) { num = num.substring(0, num.length() - 1); } // 删完了，break if (num.length() == 0) { return &quot;0&quot;; } } if (num.length() == 0) { return &quot;0&quot;; } return Integer.valueOf(num).toString(); }}``` 上面的算法已经能解决获取最小值的问题，此时思考下这个算法的复杂度 设整数长度为 n，删除 k 个数字，则时间复杂度为 `O(kn)` 因为要不断的 substring()，效率不高 可以联想栈的结构，当一个栈顶的数字比要入栈的数字大时，让栈顶数字出栈，此时就认为是删除了一个数字 **优化代码**```javaclass Solution { public String minValue(String num, int k) { // 新长度 int newLen = num.length() - k; // 栈数组 char[] stack = new char[num.length()]; // 栈顶索引 int top = 0; for (int i = 0; i &lt; num.length(); i++) { char c = num.charAt(i); // 栈不为空，栈顶元素大于c，还有删除元素 while (top &gt; 0 &amp;&amp; stack[top - 1] &gt; c &amp;&amp; k &gt; 0) { top -= 1; k -= 1; } // 当前数字入栈 stack[top++] = c; } // 判断栈中第1个非0数字 int offset = 0; // 起始位置小于新长度，判断起始位置的字符 while (offset &lt; newLen &amp;&amp; stack[offset] == '0') { offset++; } // 剩余字符全是0，或没有剩余字符 if (offset == newLen) { return &quot;0&quot;; } // 取起始位置和newLen之间的字符 return new String(stack, offset, newLen - offset); }} 至此，这个算法将遍历整数作为外层，减少了计算次数，也避免了重复的 substring() 操作","link":"/2020/11/09/alg-greedy-algorithm/"},{"title":"Java 对象创建过程","text":"Java 对象创建过程如图： Java 字节码文件结构Java Class 文件的结构 ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 } Class 文件字节码结构组织示意图 Class 文件详细结构如下： 魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。 Class 文件版本 ：Class 文件的版本号，保证编译正常执行。 常量池 ：常量池主要存放两大常量：字面量和符号引用。 访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。 当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。 接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。 字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。 方法表集合 ：类中的方法。 属性表集合 ： 在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。 Java对象创建过程1. 类加载检查当 JVM 遇到一条 new 指令时，会检查这条指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经 加载-连接-初始化，如果没有则必须完成类加载过程。类加载参考 Post not found: java-class-load Java类加载 2. 分配内存当类加载检查通过后需要给新生对象分配内存，对象所需的内存在类加载完成后便可确定大小分配内存方式有：指针碰撞和空闲列表 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的 虚拟机创建对象的过程是线程安全的虚拟机采用两种方式保证线程安全 CAS+失败重试：假设没有冲突去分配内存，因为冲突失败就重试，使用 CAS 保证操作的原子性 TLAB：为线程预先分配一块内存，JVM 给对象分配内存时优先在 TLAB 分配，TLAB 剩余空闲内存不足时，使用上面的 CAS+失败重试 分配 3. 初始化零值内存分配完成后，虚拟机需要将分配的内存空间都初始化成零值，保证对象的字段不赋初始值就能直接使用，程序能访问到这些字段类型所对应的零值 4. 设置对象头虚拟机需要为对象设置对象头对象头包含：对象所属的类、类元信息的引用、对象的哈希码、GC分代年龄等另外对象头中根据虚拟机的运行状态会有：是否启用偏向锁等 5. 执行 init 方法上面的步骤都完成后，虚拟机还会执行对象的 &lt;init&gt; 方法，按照程序员的意愿进行初始化","link":"/2020/11/04/java-object-create/"},{"title":"学习笔记 2020-10-30","text":"今天回顾了一下集合类和 GC Root 有两处需要学习的知识点：HashMap 的红黑树转换方法，ConcurrentHashMap.helpTransfer() 的原理 算法题是来自于力扣网的 123. 买卖股票的最佳时机 III 难度：困难 集合类HashMap DEFAULT_INITIAL_CAPACITY ( 1 &lt;&lt; 4 ) : 默认初始化容量 16 MAXIMUM_CAPACITY ( 1 &lt;&lt; 30 ) : 最大容量 1 &lt;&lt; 30 DEFAULT_LOAD_FACTOR : 默认负载因子 0.75 TREEIFY_THRESHOLD : 链表转红黑树阈值 8 UNTREEIFY_THRESHOLD : 红黑树转链表阈值 6 MIN_TREEIFY_CAPACITY : 链表转红黑树最小Node数组大小 64 红黑树树转链表会发生在一下两处 数组扩容，红黑树拆分后，节点数小于 UNTREEIFY_THRESHOLD 删除节点后，root, root.right, root.left, root.left.left 任何一个为 null HashMap 线程不安全的原因 JDK 1.7 HashMap 扩容的时候，链表的节点顺序会反转，因此多线程操作可能出现环，get 操作的时候会出现死循环，也有可能丢失数据 JDK 1.8 HashMap 扩容的时候，链表节点不反转，不会出现环，但是可能丢失数据 未明确的知识点？ HashMap 红黑树的转换原理 ConcurrentHashMap helpTransfer() 的原理 其它集合类 List : ArrayList , LinkedList , Vector Set : HashSet , LinkedHashSet , TreeSet Map: HashMap , LinkedHashMap , TreeMap , Hashtable 进程&amp;线程进程 是程序运行的基本单位，线程 是系统调度的基本单位进程 拥有独立的内存区域，线程 的内存区域存在 独享 和 共享 （栈、堆） new Thread() 创建了一个线程，线程进入 NEW 状态thread.start() 启动线程并使线程进入就绪状态 GC RootGC Root 是垃圾回收期标记存活对象的起点 GC Root 有哪些 Class 由系统类加载器加载的对象 Thread 激活状态的线程 Stack Local 栈中的对象 JNI Local JNI栈中的对象 JNI Global JNI中的全局对象 Monitor Used 正在被用于同步的各种锁对象 Held By JVM JVM自身持有的对象，比如系统类加载器等 算法题今天算法题来自力扣网 123. 买卖股票的最佳时机 III 难度：困难 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 思考 可以看到，对于第一次买卖： 要获取从第 0 天开始，到第 i 天内，能获取到的最大利润 需要记录前 i - 1 天最小的买入价 min 使用第 i 天的买入价 - min，得到第 i 天的利润 使用上一步的利润与第 i - 1 天的利润相比，选择较大的一个作为第 i 天的利润 对于第二次买卖： 有两种思路： 从第 n - 1 天开始计算第 n - 1 天到第 1天可以获得的最大利润 第二个思路还没看太明白，参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/10208","link":"/2020/10/30/note-2020-10-30/"},{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q. 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true输入 [1 -&gt; 2 -&gt; 1], 输出true输入 [1 -&gt; 2], 输出false输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q. 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q. 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"},{"title":"学习笔记 2020-11-02","text":"今天看了下二叉树的遍历和堆，熟悉了两者的结构和代码实现堆可以引申到优先级队列和堆排序冒泡排序的优化算法鸡尾酒排序，通过反向遍历避免极端情况快速排序有可以双边循环和单边循环了解到计数排序和引申出来的桶排序综上明白了堆排序、冒泡排序（优化的鸡尾酒排序）、快速排序、计数排序和桶排序 今日算法题：力扣网 377. 组合总和 Ⅳ 队列、堆二叉树二叉树的深度优先遍历二叉树的深度优先遍历有两种常用方法 递归方法，最常用 使用栈保存节点以先序遍历为例： 从根节点开始遍历当存在左子节点时，将当前节点入栈，继续遍历左子节点，遍历完成后将父节点出栈遍历父节点的右子节点 广度优先遍历 与深度优先遍历不同，较多使用的是队列保存已遍历的节点 从根节点开始遍历从队头依次取出节点如果取出的节点有子节点，则将子节点加入到队尾 最大堆、最小堆 最小堆(小顶堆): 所有父节点都比其子节点小 最大堆(大顶堆): 所有父节点都比其子节点大 构建堆构建堆的方式是下沉以最小堆为例 从最后一个非叶子节点开始，依次遍历非叶子节点 找到左右子节点较小的一个 父节点与上一步找到的最小的节点比较，如果比子节点大，则交换两个节点位置，否则回到第一步 将用于交换的子节点作为新的父节点，从第2步重新开始比较 构建最大堆与最小堆的区别第2步找到较大的一个第3步如果比子节点小则交换位置 插入/删除节点 插入节点：新插入的节点作为最后一个节点，做上浮操作 删除节点：从堆顶删除节点，将最后一个节点放到堆顶，做下沉操作 上浮/下沉代码示例 上浮操作 1234567891011private void upAdjust(int[] array) { int childIdx = array.length - 1; int parentIdx = (childIdx - 1) / 2; int temp = array[childIdx]; while (childIdx &gt; 0 &amp;&amp; temp &lt; array[parentIdx]) { array[childIdx] = array[parentIdx]; childIdx = parentIdx; parentIdx = (childIdx - 1) / 2; } array[childIdx] = temp;} 下沉操作 123456789101112131415161718192021private void downAdjust(int[] array, int parentIdx) { int len = array.length; int temp = array[parentIdx]; int childIdx = parentIdx * 2 + 1; while (childIdx &lt; len) { // 如果有右孩子，并且右孩子比左孩子小，则与右孩子交换 if (childIdx + 1 &lt; len &amp;&amp; array[childIdx + 1] &lt; array[childIdx]) { childIdx++; } if (temp &lt;= array[childIdx]) { break; } // 将左/右孩子上移 array[parentIdx] = array[childIdx]; // 孩子节点作为新的父节点 parentIdx = childIdx; // 下一个孩子节点 childIdx = parentIdx * 2 + 1; } array[parentIdx] = temp;} 优先级队列优先级队列的一种实现方式是使用最大堆 入队：新插入的节点作为最大堆的最后一个节点，然后上浮 出队：从最大堆顶删除节点 排序算法堆排序堆排序的实现方式 从排序数据构建堆，升序-&gt;最大堆，降序-&gt;最小堆 将堆顶元素与最后一个节点交换位置 新的堆顶元素下沉，下沉的界限是未排序的部分 鸡尾酒排序鸡尾酒排序与冒泡排序类似遍历的方式改为：从左往右遍历，再从右往左遍历如果某一个遍历未发生交换，则认为数据已经有序 快速排序 双边循环法 选择一个基准元素left和right两个索引分别向中间移动，和交换元素，left索引需要优先于right索引移动，否则影响下一步的交换当两个索引重合时，索引指向的元素和基准元素交换位置以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 单边循环法 以最左边元素为基准元素指定mask指针指向基准元素往右遍历，如果有比基准元素小的元素时，mask指针向右移动一位，与遍历的元素交换位置当遍历完后，mask指针指向的元素与基准元素交换以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 快速排序的非递归实现 将每一步产生的两段的start、end索引放入到一个栈中弹出元素遍历，将新的两段重新入栈，直至栈清空 计数排序排序方式 获取数组元素的最小和最大值以最小和最大值的距离创建一个countArray数组遍历数组，将数组元素对应countArray数组位置的值+1遍历统计数组，输出结果 缺点只能排序整数数组，如果数组含有小数则无法排序最小值和最大值差距过大是造成空间浪费 桶排序排序方式 获取数组元素的最小和最大值，得到最大值与最小值的间距d以最小和最大值的距离创建一个List的数组遍历数组，(array[i] - min) / d * (数组大小 - 1)将元素放入上一步找到的桶List中每个List内部进行排序遍历数组，输出每个List的值 缺点最小值和最大值差距过大是造成空间浪费 算法题LeetCode 377. 组合总和 Ⅳ今天算法题来自于力扣网 377. 组合总和 Ⅳ 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 123456789101112131415示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 基本思路 动态规划是每次第i+n位置加上第i位置的排列数递归法是计算每个target-n的排列数之和 代码实现 动态规划 12345678910111213141516class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; Arrays.sort(nums); dp[0] = 1; for (int i = 0; i &lt; target; i++) { for (int n : nums) { if (i + n &lt;= target) { // dp数组位置+n，既新的位置多了dp[i]种排列 dp[i + n] += dp[i]; } } } return dp[target]; }} 递归 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { if (target == 0) { return 1; } int count = 0; for (int n : nums) { if (target &gt;= n) { // target的排列数 = 每个target-n的排列数之和 count += combinationSum4(nums, target - n); } } return count; }}","link":"/2020/11/02/note-2020-11-02/"},{"title":"学习笔记 2020-11-04","text":"今天学习了JVM的内存结构和GC策略；代码实现了链表环的检测、获取环长度和入口今日算法题：力扣网 139. 单词拆分 JVMJVM内存结构 虚拟机栈 栈由栈帧组成，一个栈帧包含：局部变量表、操作数栈、动态链接、方法出口，局部变量表所需内存大小在编译器确定方法调用的方式：每一次方法调用都会有一个对应的栈帧入栈，方法调用结束后出栈现在的Java虚拟机的栈一般允许动态扩展，即栈空间不足时动态扩展栈空间大小 当栈的深度达到最大深度时，抛出 StackOverflowError当栈空间内存无法扩展时，抛出 OutOfMemoryError 本地方法栈 与虚拟机栈类似区别是虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务在HotSpot虚拟机中，虚拟机栈和本地方法栈合二为一。 程序计数器 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码流程控制，如：顺序执行、循环、选择、异常处理等；程序计数器可以记录线程执行的位置，当线程上下文切换时可以知道上一次线程运行到哪儿了 程序计数器的生命周期和线程一致，是唯一不会发生 OutOfMemoryError 的内存区域 堆 线程共享的区域，用于存放存活对象的实例堆的垃圾回收一般采用分代收集算法，因此堆可以分为：新生代和老年代新生代可以细分为：Eden, From Survior, To Survior, （Eden, S0, S1） 方法区 《Java虚拟机规范》定义了方法区这个概念和它的作用，并没有规定怎么去实现永久代是 HotSpot 虚拟机对虚拟机规范中方法区的实现，方法区存放：Java类信息、常量池、静态变量、JIT编译的代码数据 从JDK 1.7 开始，字符串常量池 移到堆中从JDK 1.8 开始，字符串常量池 和 静态变量 移到了堆中，方法区被彻底移除，使用元空间替代，元空间申请在直接内存中 JDK 1.7 及之前，可以使用 -XX:PermSize=N 和 -XX:MaxPermSize=N 配置方法区大小，超出内存将抛出 OutOfMemoryError: PermGen 异常JDK 1.8 及之后，使用 -XX:MetaspaceSize=N 和 -XX:MaxMetaspaceSize=N 配置元空间大小，上限默认为 unlimited，只受系统内存限制 直接内存 直接内存不是JVM运行时数据区的一部分直接内存只受系统内存空间的限制Java NIO中，通过 Native 方法直接分配堆外内存，然后通过存储在堆上的 DirectByteBuffer 作为这块内存的引用进行操作，减少数据在 Java 堆 和 Native 堆 之间的来回复制 运行时常量池方法区中存放着class文件的信息和运行时常量池 class文件的信息包含类型西和静态常量池，静态常量池结构如下图 当类加载到内存中时：加载阶段：JVM将class类的静态常量池的内容放入运行时常量池解析阶段：JVM将常量池中的符号引用替换为直接引用 在JDK 1.7，字符串常量池移到了堆中在JDK 1.8，静态变量移到了堆中，剩余的放到位于直接内存的 MetaSpace 中 字符串常量池存放的是字符串对象的引用，字符串对象仍然在堆中 对象创建对象创建，参考 Java 对象创建过程 GC 垃圾收集垃圾回收算法：复制、标记-清除、标记-整理Minor GC: 新生代GCMajor GC：老年代GCFull GC：清理整个堆，包括年轻代、老年代和方法区垃圾收集，参考 JVM 垃圾收集 算法链表中环的问题有一个链表如图 Q1. 判断链表中是否存在环 方法1：一个指针从头开始遍历链表，每遍历一个节点，就从头检查一下这个节点是否被遍历过时间复杂度：O(n^2), 空间复杂度：O(1) 方法2：从头遍历链表，将已遍历的节点放入一个Hash表中，没遍历一个新节点判断一下这个节点是否在Hash表中时间复杂度：O(n), 空间复杂度：O(n) 方法3：有两个快慢指针分别从头遍历链表，快指针每次移动2步，慢指针每次移动1步如果链表中有环，那么快指针移动会在经过 n 个环后追上慢指针 (n &gt;= 1) 方法3的做法如图 可以看到两个指针从起点 S 出发，最终相遇于环内 代码实现 123456789101112131415public boolean isCycle(Node head) { Node fast = head; Node slow = head; while (fast != null &amp;&amp; fast.next != null) { // 快指针每次移动2步 fast = fast.next.next; // 慢指针每次移动1步 slow = slow.next; // 快慢指针相遇 if (fast == slow) { return true; } } return false;} Q2：求链表环的长度依据上一个问题的方法3，快慢指针的速度相差1。因此当两个指针到达相遇点后，让两个指针记录移动当两个指针再次相遇时，慢指针走过的距离既是环的长度 Q3: 找到环的入环节点继续参考这张图当两个指针相遇时两个指针走过的距离： 快指针 = D + S1 + n * (S1 + S2), (n &gt;= 1) 慢指针 = D + S1 由于快指针是慢指针的速度的2倍因此： 2(D + S1) = D + S1 + n(S1 + S2), (n &gt;= 1)可以推出： D = (n-1)(S1 + S2) + S2, (n &gt;= 1) 因此可以把其中一个指针放到首次相遇点，另一个指针放到头节点位置，两个指针每次都各向前走1步，当两个指针再次相遇时，相遇的点就是入环节点 力扣网：139. 单词拆分Q: 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 思路看到这一题可以想到的是暴力求解，但是这种思路的时间复杂度和空间复杂度都很高这个问题其实也可以看成是，已知字符串 s 的前 n 个字符已经在给定的字典中，求剩下的字符是否在给定的字典中那么这个问题就会转化成动态规划的背包问题 实现 解法1：遍历字符串 s, 前i个字符是否在字符串中，既当前 j 个字符在字典中时第 (j, i) 个字符是否在字典中 1234567891011121314151617class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (int j = 0; j &lt; i; j++) { // 当前第j个字符在字典中，判断 (j, i) 是否在字典中 if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这种方式存在重复计算的问题，每次都需要将前 i-1 个字符计算一遍解法2对这个问题做了些优化 解法2：遍历字符串 s 时，通过遍历字典，判断字典是否是当前已遍历部分的末尾，和字典字符串的前一个字符的 dp 位置是否为 true 12345678910111213141516171819class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (String str : wordDict) { // i &gt;= str.length(): 避免多余的判断 // dp[i - str.length()]: 判断dp位置 i - str.length()，表示去除末尾字符串str后剩下的字符串是在字典中 // s.substring(i - str.length(), i): 判断str是否是已遍历字符串的末尾部分 if (i &gt;= str.length() &amp;&amp; dp[i - str.length()] &amp;&amp; str.equals(s.substring(i - str.length(), i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这个问题有个变形的题目 力扣网：140. 单词拆分 II输出所有的拆分情况比较简单的思路是从字符串首部取字典中存在的部分，然后递归遍历子串， 有两处可以优化的可以使用 139. 单词拆分 的思路判断子串是否在字典中，优化时间效率可以使用Hash表的方式记录每个子串是否在字典中 使用 139 问题的思路优化后所需时间大幅减少 这一题看题解有使用回溯的思想做的，需要研究下回溯怎么实现的TODO 使用回溯的思想求解 140. 单词拆分 II","link":"/2020/11/04/note-2020-11-04/"},{"title":"两个数最大公约数","text":"有两个正整数，求两个数的最大公约数。这个问题有几种常见的算法 暴力破解 辗转相除法 更相减损法 在本文中将这个问题做一些探究 以下内容为了精简代码，均认定代码两个参数 big &gt;= small 暴力破解暴力破解既循环遍历，判断是否为两个数的公约数这里可以有些推论： 一个数 n 的最大约数是其本身，因此这个数第二大的约数必定 &lt;= n / 2 遍历公约数的时候可以从 min / 2 开始遍历 以下代码 123456789101112131415161718192021222324252627282930313233public int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } for (int i = small / 2; i &gt; 1; i++) { if (big % i == 0 &amp;&amp; small % i == 0) { return i; } } return 1;}``` 这个方法很直观明了，缺点是当两个数相差很小，如 10000, 10001，需要计算的次数很多 ## 辗转相除法**辗转相除法** 又名 欧几里得算法，可追溯到公元前300年 该算法的思想基于一条定理：如果两个正整数 a 和 b (a &gt; b)，它们的最大公约数等于 a / b 的余数与 b 之间的最大公约数 假设最小公约数是 q，那么 a = m * q, b = n * q a = (m - i * n) * q + (i * n) * q = (m - i * n) * q + i * (n * q) 当 (m - i * n) * q &lt; n 时，a / b 的商为：i， 余数为：(m - i * n) * q **代码实现**```javapublic int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } return getGreatestCommonDivisor(small, big % small);} 这个算法计算次数很少，存在的缺点是当两个数都很大时，取余操作性能比较差 更相减损法更相减损法 来自于《九章算术》基本思路是两个数的最大公约数是两个数只差与较小的数的最大公约数从本质上来看，这个算法的思路与辗转相除法类似，但是这个算法使用减法运算大大降低了计算难度计算次数就比辗转相除法多一些 代码实现 123456public int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } return getGreatestCommonDivisor(small, big - small);} 位移运算+更相减损法两个整数 a 和 b 存在三种场景 a 和 b 均为偶数：此时 f(a, b) = 2 * f(a/2, b/2) = 2 * f(a&gt;&gt;1, b&gt;&gt;1) a 为奇数，b 为偶数：f(a, b) = f(a, b/2) = f(a, b&gt;&gt;1) a 和 b 均为奇数：先使用更相减损法，f(a,b) = f(b, a-b)，此时已经符合场景2，可以继续使用场景2的方式计算 代码实现 12345678910111213141516171819202122public int getGreatestCommonDivisor(int a, int b) { if (a == b) { return a; } // &amp;1 代替余2, &lt;&lt;1 代替乘2 if ((a &amp; 1 == 0) &amp;&amp; (b &amp; 1 == 0)) { return getGreatestCommonDivisor(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; } else if ((a &amp; 1 == 0) &amp;&amp; (b &amp; 1 != 0)) { return getGreatestCommonDivisor(a &gt;&gt; 1, b); } else if ((a &amp; 1 != 0) &amp;&amp; (b &amp; 1 == 0)) { return getGreatestCommonDivisor(a, b &gt;&gt; 1); } else { if (a &lt; b) { // 0^0=0, 0^1=1, 1^0=1, 1^1=0 // a ^ b ^ b == a a = a ^ b; b = a ^ b; a = a ^ b; } return getGreatestCommonDivisor(a - b, b); }} 这种方式极大简化了辗转相除法的除法运算，也减少了更相减损法的计算次数，效率比较高 补充一个算法 判断一个数是否为2的整数次幂除了传统的 /2 计算外，可以使用位运算优化如： 16 = 1000016 - 1 = 15 = 111110000 &amp; 1111 == 0 因此这个问题可以简化为判断 1return n &amp; (n-1) == 0;","link":"/2020/11/05/alg-greatest-common-divisor/"},{"title":"学习笔记 2020-11-09","text":"今天看了一些算法问题。下面给出一个常见的算法问题的思路和解决办法 寻找全排列的下一个数 大整数加法 寻找缺失的数：99个1-100范围内的不重复数，出现奇数次的1个/2个数 算法寻找全排列的下一个数问题给定一个数，找出这个数中数字全排列的下一个数，如：12345 -&gt; 1235412354 -&gt; 12435 思路如果一个数后面的数时顺序的，如：45，那么下一个数一定是最后的两个数倒序，既：54同理，如果后面的数时倒序的，就说明后面已经是最后一个排列，下一个全排列的数就需要网前一位看，如：354，下一个数应该要从 3 开始看 代码实现 123456789101112131415class Solution { public String nextSeq(String num) { for (int i = num.length() - 1; i &gt; 0; i--) { // 找到比前一个数字大的数字的位置 if (num.charAt(i) &gt; num.charAt(i-1)) { // 前一部分保持不变，后一部分反转，找到的数字放到最后面 return num.substring(0, i-1) + new StringBuffer(num.substring(i)).reverse().toString() + num.charAt(i-1); } } // 数字已经是倒序了 return num; }} 大整数加法思路 按位加 拆分成可以计算的数第一种方法使用数组存放大整数，从低位到高位按位加，代码省略方法2的实现 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution { public String bigNumberAdd(String n1, String n2) { int numLen = n1.length() &gt; n2.length() ? n1.length() : n2.length(); int len = numLen / 9 + 1; int[] arr1 = parseNum(n1, len); int[] arr2 = parseNum(n2, len); // 按数组为相加，如果 &gt; 999999999, 则往下一位+1 for (int i = 0; i &lt; len; i++) { arr1[i] = arr1[i] + arr2[i]; if (i &lt; (len - 1) &amp;&amp; arr1[i] &gt; 999999999) { arr1[i + 1] = arr1[i + 1] + 1; arr1[i] = Integer.valueOf(String.valueOf(arr1[i]).substring(1)); } } // 组装结果 StringBuilder res = new StringBuilder(); boolean fill = false; for (int i = len - 1; i &gt;= 0; i--) { if (arr1[i] &gt; 0 || fill) { // 判断是否需要填充0 if (fill) { res.append(fillZero(arr1[i])); } else { res.append(arr1[i]); fill = true; } } } return res.toString(); } /** * 填充0 * @param n * @return */ private String fillZero(int n) { String ns = String.valueOf(n); StringBuilder str = new StringBuilder(n); for (int i = 0; i &lt; 9 - ns.length(); i++) { str.append('0'); } str.append(ns); return str.toString(); } /** * 字符串转成int数组 * @param num * @param len * @return */ private int[] parseNum(String num, int len) { int[] arr = new int[len]; int nLen = num.length() % 9 == 0 ? num.length() / 9 : num.length() / 9 + 1; int pos = nLen - 1; for (int i = 0; i &lt; nLen; i++) { // 12 345678912 345678900 int start = num.length() - (i + 1) * 9; int end = num.length() - i * 9; if (start &lt; 0) { start = 0; } arr[i] = Integer.valueOf(num.substring(start, end)); } return arr; }} 寻找缺失的数问题问题 有99个不重复数，取值范围是1-100，要求找出缺失的那个数 有若干个正整数，其中n个数出现了偶数次，另有1个整数出现了奇数次，要求找出这个出现奇数次的数 有若干个正整数，其中n个数出现了偶数次，另有2个整数出现了奇数次，要求找出这2个出现奇数次的数 思路 问题1：计算1-100内所有数的和，减去99个不重复数的和，结果就是缺失的那个数 问题2:由于两个相同数异或后为0，所以将所有的数异或后，结果就是出现奇数次的那个数 问题3:按照问题2的方法得到一个数，找到根据出现1的位异或，可以找到两个数 代码实现 1234567891011121314151617181920212223242526class Solution { public void twoNum(int[] nums) { // 异或 int n = 0; for (int i = 0; i &lt; nums.length; i++) { n ^= nums[i]; } // 找到两个数的不同位 int bit = 1; while ((bit &amp; n) == 0) { bit &lt;&lt;= 1; } int r1 = 0; int r2 = 0; for (int i = 0; i &lt; nums.length; i++) { // 依据不同位分组所有的数并异或，得到两个出线奇数次的数 if ((nums[i] &amp; bit) == 0) { r1 ^= nums[i]; } else { r2 ^= nums[i]; } } System.out.println(r1); System.out.println(r2); }}","link":"/2020/11/09/note-2020-11-09/"},{"title":"学习笔记 2020-11-11","text":"今天分享一些算法 BitMap: 位图，按位存储元素，可以很方便通过位过滤元素 LRU: 最近最少使用算法 A* Search: A星寻路算法，用于解决迷宫问题，找到最短路径 发红包问题: 解决发红包中奖概率问题 数据结构BitMap使用BitMap按位存储元素过滤 场景: 有一个文件包含10亿个数，找到给定的数m是否在文件中 此处假定所有的数都是正整数 已知一个int类型的长度是32bit, 可以将每32个数放到一个int中 定义一个长度为 10亿 / 32 的整数数组 给定一个数 n, n&gt;&gt;5 表示 n 可以放到第 n&gt;&gt;5 个数组元素中 1 &lt;&lt; (n &amp; 0xffffffff) 的值表示将这一位标记为 1, 表示数 n 存放的位置 将所有的10亿个数依次放到指定位置 判断 m 所在的位置是否有值即可判断 m 是否在文件中需要的内存空间为 10亿bit = 954M 场景: 有一个文件包含2.5亿个数，找出出现超过1次的数 这一个场景与上一个场景类似，区别在于需要标记一个数出现超过1次，则可能的标记为为：未出现、出现1次、出现2次以上需要的 2 位标记位因此一个int类型只能存放16个数所需空间为: 2.5亿 * 2bit = 5亿bit = 477M LRU算法 - 哈希链表在数据之间维护一个链表 A* Search (A星寻路算法) 从起点出发，将起点放入openList标记起点的相邻节点，如果节点不在openList或closeList中，则将节点放入openList，并记录标记起点为相邻节点的父节点计算相邻节点到目标点的无视障碍的最短距离将起点从openList移到closeList从openList里面找到一个F值最小的节点，作为新的起点计算 发红包设总金额为m，人数为n 二倍均值法假设一个人抢红包，那么这个人抢到的红包金额平均为总金额的一半假设m=100， n=5n1 = [0.01, 100 / 5 * 2 - 0.01] = [0.01, 39.99] ~ 20n2 = [0.01， 80 / 4 * 2 - 0.01] = [0.01, 39.99] ~ 20n3 = [0.01， 60 / 3 * 2 - 0.01] = [0.01, 39.99] ~ 20n4 = [0.01， 40 / 2 * 2 - 0.01] = [0.01, 39.99] ~ 20n5 = [0.01， 20 / 1 * 2 - 0.01] = [0.01, 39.99] ~ 20 金额 = 随机取件[0.01, m/n*2 - 0.01] 随机切割法总金额m的红包，随机切割区间是[0.01, m-0.01]，n个人抢红包，随机切割n次","link":"/2020/11/11/note-2020-11-11/"},{"title":"学习笔记 2020-11-13","text":"今天完整学习了Redis，本文包含： Redis 数据类型 Redis IO模型 过期淘汰机制 快照和持久化 缓存一致性问题 缓存为什么使用缓存 缓存的数据操作都在内存中，读写效率比数据库高 缓存可以很方便的调整集群大小，当性能要求高时可以很方便扩容 缓存的数据操作简单，不存在数据库复杂的查询优化、锁、事务机制问题 Redis特点 支持丰富的数据结构，除了最简单的 k-v 存储外，还支持 list, set, zset, hash，string(k-v) 支持数据持久化，可以把内存中的数据保存在磁盘中，重启时可再次加载，具备容灾机制 内存不足时可以将部分数据保存到磁盘中 原生支持 cluster 集群模式 Redis 使用单线程多路复用IO，6.0版本增加多线程，Memcached使用多线程非阻塞IO复用的网络模型 Redis 支持订阅、lua脚本和事务 过期数据，Redis使用惰性删除和定期删除，Memcached只能使用惰性删除 Redis数据类型 string: 最简单的 k-v 存储，使用 SDS(简单动态字符串)，支持字符串和二进制数据，不会出现缓冲区溢出 支持：set, get, del, strlen, exists, decr(–1), incr(++1)支持批量操作: mset, mget设置过期时间: expire(expire key 60), setex(setex key 60 value), ttl(ttl key, 返回过期时间), persist(删除过期时间) list: 链表，Redis中的链表是双向链表，支持顺序和反向查找 支持：lpush, lpop, rpush, rpop, lrange, llen, lrem常用命令 123456rpush key value1 value2 # 向 list 的头部（右边）添加元素lpushx key value # 只有key存在时添加 lpop key # 将 list的尾部(最左边)元素取出 lrange key 0 1 # 查看对应下标的list列表,0:start,1:end lrange key 0 -1 # 查看列表中的所有元素，-1表示倒数第一lrem key 2 value # 删除2个值为value的元素 hash: 类似于 HashMap，是 string 类型的 field 和 value 的映射 支持：hset, hmset, hget, hgetall, hexists, hkeys, hvals旧版本 hset 只能设置一个值，新版本功能和 hmset 一样可以设置多个值 set: 类似于 HashSet，数据不能重复，可以很方便的求交集、并集、差集 支持：sadd, spop, smembers, sismember, scard(set的元素数量)支持：sinter(交集), sunion(并集), sdiff(差集)支持：sinterstore, sunionstore, sdiffstore，与上面的区别是：将计算结果保存到另一个 set 中 sorted-set: 增加了 score(权重)，能够让元素按照 score 有序排序 支持：zadd, zcard, zrange, zrevrange, zrem支持：zlexcount(min max), zpopmin, zpopmax Redis的IO模型 Redis 基于 Reactor 模式来设计开发了一套高效的时间处理模型，对应 Redis 中的文件事件处理器（file event handler） Redis 使用多路复用IO，将感兴趣的事件及类型（读、写）注册到内核，并监听每个时间是否发生，类似于 NIO 的 Selector 组件 Redis 基于事件驱动：文件事件和时间事件 Redis 4.0增加了多线程，主要针对大键值对的删除操作 Redis 6.0多线程改进，主要针对网络IO Redis过期删除机制Redis通过过期字典记录key的过期时间，过期字典的key指向键值的key，value是一个 long long 类型的整数，记录 unix 毫秒时间戳 Redis内存淘汰机制 volatile-lru: 从已设置过期时间的数据中，淘汰最近最少使用的数据 volatile-ttl：从已设置过期时间的数据中，淘汰即将过期的数据 volatile-random: 从已设置过期时间的数据中，随机淘汰部分key allkeys-lru: 从所有数据中，淘汰最近最少使用的数据 allkeys-random：从所有数据中，随机淘汰部分key no-eviction：禁止淘汰数据 volatile-lfu：从已设置过期时间的数据中，淘汰最不经常使用的数据 allkeys-lfu：从所有数据中，淘汰最不经常使用的数据 volatile-lfu 和 allkeys-lfu 是4.0版本新加的 Redis快照和持久化 快照：存储某个时间点数据的副本 数据完整性好，效率比较低save 300 10: 300秒内，10个key变动则触发 BGSAVE 命令保存快照 持久化：存储执行的命令 记录每个修改操作命令appendonly yes: 开启持久化appendfsync always: 实时保存命令，everysec：每秒保存一次，no：让操作系统决定什么时候保存 Redis 4.0开始支持混合持久化 AOF重写时直接将RDB的内容写到AOF文件头，结合了快照和持久化的优点使用 aof-use-rdb-preamble 开启 Redis 事务Redis 通过 MULTI, EXEC, DISCARD, WATCH 命令实现事务Redis 事务不支持回滚，因此不满足原子性，原子性有业务代码解决 MULTI: 开启事务 EXEC: 提交事务 DISCARD: 取消事务 WATCH: 监视多个key，当key被修改时取消事务 UNWATCH: 取消监视key 缓存穿透和缓存雪崩 缓存穿透：查询key未命中缓存 缓存无效key：将无效的key缓存一个控制，同时设置较短的过期时间使用布隆过滤器过滤key 缓存雪崩：同时有查询未命中缓存，导致查询都压到数据库 使用Redis集群：避免单机压力过大限流设置不同的过期时间，如在固定的过期时间上加个随机时间缓存永不过期 如何保存缓存和数据库一致性 删除缓存后更新数据库记录：存在更新数据库前读取缓存的问题 更新数据库记录后删除缓存：存在删除缓存前读取到旧缓存数据的问题 通知执行1和2的操作：重复操作，或许会影响性能 订阅数据库binlog：如果更新数据很多，订阅binlog有延迟，也会存在2的问题。如果更新数据不会很多，不一致的时间应该会比2小 旁路缓存模式 设置短的缓存失效时间：治标不治本 增加缓存更新重试机制：当cache不可用时，隔段时间重试；如果多次重试后仍不可用，则将更新失败的key加入队列，待缓存可用时再将缓存中的key删除","link":"/2020/11/13/note-2020-11-13/"},{"title":"学习笔记 2020-11-12","text":"今天学习了数据库 数据库的元组、码、属性 范式：1NF、2NF、3NF、BCNF 数据库事务 索引 MyISAM 和 InnoDB 的区别 数据库数据库基础知识 元组：一行记录 码：可以唯一标识实体的属性，对应表中的列 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。通俗来说就是可以被选为 主码 的的属性或属性组 主码：主键，从候选码中选出来的 外码：外键 主属性：候选码中出现过的属性 非主属性：不包含在任何一个候选码中的属性 范式和函数依赖范式 1NF(第一范式)：属性不可分割 2NF(第二范式)：消除非主属性对码的部分函数依赖 3NF(第三范式)：消除非主属性对码的传递函数依赖 BCNF：不存在任一字段对候选关键字段的传递函数依赖，在3NF的基础上消除关键字段决定关键字段的情况 函数依赖 函数依赖：若一个表中能由 X 唯一确定 Y，则称 Y 函数依赖于 X，写作 X -&gt; Y 部分函数依赖：如果 X -&gt; Y，并且存在 X 的真子集 X0 -&gt; Y，则 Y 部分函数依赖于 X 完全函数依赖：若一个非主属性数据项依赖于全部关键字，则称之为完全函数依赖 传递函数依赖：在关系模式R(U)中，如果 X -&gt; Y，Y -&gt; Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z = 空集合，则称 Z 传递函数依赖于 X 事务事务：一组操作要么都不执行，要么都执行 事务的ACID属性 原子性：事务是执行的最小单位，要么都完成，要么都不完成 一致性：执行事务前后数据保持一致，多个事务对同一条记录的读取结果是相同的 隔离性：一个事务不被其他事务所干扰 持久性：事务一旦提交，所有的都将保存下来 事务带来的问题 脏读：读到其他事务未提交的数据 丢失修改：一个事务的修改被另一个事务所覆盖 不可重复读：一个事务两次读取同一条记录，读取的数据不一样 幻读：一个事务使用同样的条件查询，两次查询到的记录数不同 事务的隔离级别 READ-UNCOMMITED：读未提交，可能造成脏读、不可重复读、幻读 READ-COMMITED：读已提交，防止脏读，可能造成不可重复读、幻读 REPEATABLE-READ：可重复读，防止脏读、不可重复读，可能造成幻读 SERIALIZABLE：可串行化，防止脏读、不可重复读、幻读 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITED √ √ √ READ-COMMITED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × MySQL隔离级别MySQL中 InnoDB 引擎 REPEATABLE-READ 隔离级别下使用 Next-Key Lock 算法，避免了幻读，所以 InnoDB 引擎默认支持的最高隔离级别是 REPEATABLE-READ 索引 索引：提高查询效率，帮助避免数据库排序，将随机IO变成顺序IO，加速表之间连接，使用唯一索引可以避免出现重复数据 MySQL中主要使用的索引：BTree 和 Hash 索引 Hash: 哈希表结构存储，适用于所有的key唯一的情况，其他情况适用于BTree BTree: B+树，所有的key都在非叶子节点，value在叶子节点 MyISAM和InnoDB中BTree的区别 MyISAM：索引和数据放在两个不同的文件上，先从索引文件查询key找到数据位置，再读取数据，这种索引称为 非聚簇索引 InnoDB：索引和数据放在同一个文件，主键索引BTree的叶子节点包含记录的全部字段，这种索引称为 聚簇索引辅助索引的叶子节点存放的是主键，先查询到主键，再从主键索引找到数据，使用的非聚簇索引 InnoDB 中尽量使用业务无关的自增主键作为索引，避免使用业务字段 创建索引方式 123456789101112# 添加Primary索引ALTER TABLE `table_name` ADD PRIMARY KEY (`key`);# 添加UNIQUE(唯一索引)ALTER TABLE `table_name` ADD UNIQUE (`key`);# 添加INDEX(普通索引)ALTER TABLE `table_name` ADD INDEX (`key`);ALTER TABLE `table_name` ADD INDEX (`key1`, `key2`);# 添加FULLTEXT(全文索引)ALTER TABLE `table_name` ADD FULLTEXT (`text`); MyISAM和InnoDB的区别 MyISAM只支持表锁，InnoDB支持表锁和行锁，默认为行锁 MyISAM不支持事务，执行速度更快，InnoDB支持事务和崩溃后的恢复 MyISAM不支持外键，InnoDB支持外键 InnoDB支持MVCC，仅在 READ-COMMIT 和 REPEATABLE-READ 隔离级别下可以用，详细内容参考MySQL-InnoDB-MVCC多版本并发控制 乐观锁和悲观锁 索引 覆盖索引：索引包含了所有需要查询的字段 使用索引的注意事项 索引作用于经常搜索的列可以加快搜索速度 索引作用于经常排序的列上可以避免服务器排序，因为索引已经是有序的 索引加在需要连接的字段上可以加速表连接 where条件中对字段加函数，会让索引无法命中 NUll值会让数据库放弃索引，因此对索引字段添加 Not Null 约束 避免建立不必要的索引，对表的更新操作也需要维护索引，删除长期不用的索引 最左前缀匹配原则对于联合索引，如果查询字段是索引的最左边的字段，那么数据库将根据联合索引搜索，否则索引将失效如 Index(A,B,C)，如果查询A和B字段，索引有效，如果查询A和C字段，只有A字段能使用索引数据库引擎会自动优化字段顺序，如果查询(B,A)字段，数据库引擎将自动优化成查询(A,B) 存储过程存储过程：可以把存储过程看作一些SQL的集合+控制语句 DROP, TRUNCATE, DELETE 的区别 DROP: DDL语句，删除表结构和数据 TRUNCATE: DDL语句，删除表中的所有数据 DELETE: DML语句，根据条件删除数据 数据库设计阶段 需求分析 概念结构设计，主要采用E-R模型进行设计，包括画E-R图 逻辑结构设计，将E-R图转换成表 物理结构设计，确定数据库的存储结构和存储位置 数据库实施，数据库的编码、测试、是运行 数据库运行和维护，系统运行和数据库日常维护 大表的优化 限定数据范围：查询必须带条件，只查询一段范围内的数据 读写分离：拆分成写库和读库 垂直分区：一个表的多个字段拆分到多个表中，可以减少查询block数，但是需要查询冗余字段时需要join 水平分区：根据数据区间分成多个表，可以解决单表数据量过大问题，但是存在分布式事务问题","link":"/2020/11/12/note-2020-11-12/"},{"title":"学习笔记 2020-11-17","text":"今天学习了 Zookeeper，Dubbo DubboDubbo 的特性 负载均衡：同一个服 务在不同的机器上时应该调用到那台机器 服务调用链路生成： 服务访问压力及时长统计、资源调度和治理： 服务降级 Dubbo 的架构 Provider: 暴露服务的服务提供方 Consumer: 调用远程服务的服务消费者 Registry: 服务注册于发现的注册中心 Monitor: 统计服务的调用次数与调用时间的监控中心 Container: 服务运行容器 Dubbo 的分层 service: 接口层，给服务提供者和消费者实现 config: 配置层，主要对 dubbo 进行各种配置 proxy: 服务接口透明代理，主要生成客户端Stub和服务端Skeleton registry: 服务注册层，负责服务的注册与发现 cluster: 集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务 monitor: 监控层，对rpc接口的调用次数和调用时间进行监控 protocol: 远程调用层，封装rpc调用 exchange: 信息交换层，封装请求响应模式，同步转异步 transport: 网络抽象层，抽象mina和netty为统一接口 serialize: 序列化层，数据传输需要 Dubbo 的负载均衡策略 Random LoadBalance: 基于权重的随机负载均衡机制 RoundRobin LoadBalance: 基于权重的轮询负载均衡机制 LeastActive LoadBalance: 最少活跃调用数 ConsistentHash LoadBalance: 一致性Hash 相同的参数发送到同一服务提供者","link":"/2020/11/17/note-2020-11-17/"},{"title":"动态规划问题","text":"动态规划：问题的最优解如果可以由子问题的最优解推导得到，则可以先求子问题的最优解，再构造原问题的最优解。若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题最终求解。 本文内容包含了几个常见的动态规划问题 金矿问题：简单动态规划 金矿问题国王有n个金矿和w个工人，每个金矿的黄金储量和需要的工人数不同。每个金矿要么不挖，要么全挖，不能只派一部分工人或者只挖一部分。要求计算出国王能挖出的最多黄金和选择挖哪几座金矿？ 如有5个金矿，10个工人，每个金矿的产量和需要的工人数如下：产量 | 人数 | -200kg | 3人300kg | 4人350kg | 3人400kg | 5人500kg | 5人 思路 思路1：贪心算法的思想 计算每个金矿的性价比，按照性价比的从高到低选择挖的金矿能用简单计算出局部最优解，但是局部最优解不一定是全局最优解 思路2：动态规划的思想 设金矿总数 n, 工人总数 w, 每个金矿产量 g[n], 需要的人数 p[n]第 n 个金矿要么挖，要么不挖，那么对于前 n-1 个金矿，可以消耗的工人就是 w 或 w - p[n]如果挖，f(n, w) = f(n-1, w - p[n]) + g[n]如果不挖，f(n, w) = f(n-1, w)因此可以得到状态转移方程 f(n, w) = max(f(n-1, w), f(n-1, w-p[n]) + g[n]) 代码实现 12345678910111213141516171819202122232425class Solution { public int maxProfit(int[] golds, int[] persons, int maxPerson) { // 建立dp数组 int[][] dp = new int[golds.length + 1][maxPerson + 1]; // 遍历金矿 for (int i = 1; i &lt;= golds.length; i++) { // 遍历1-maxPerson个工人 for (int j = 1; j &lt;= maxPerson; j++) { if (j &gt;= persons[i - 1]) { /** * dp[i-1][j]: i-1个金矿，j个工人 --&gt; 不挖 * dp[i - 1][j - persons[i - 1]]: i-1个金矿, j-persons[i-1]个工人 --&gt; 挖第i个金矿 */ dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - persons[i - 1]] + golds[i - 1]); } else { // 人手不足，取第i-1个金矿的收益 dp[i][j] = dp[i - 1][j]; } } } // 返回dp数组的最后一个 return dp[golds.length][maxPerson]; }} 上面一种算法的dp数组使用的二位数组，实际计算中每次只取上一行数据计算，因此可以简化成一维数组简化成一维数组后，需要注意不能覆盖了未参与计算的值，如:dp[i] = dp[i-1], dp[i] 应该作为 dp[i+1] 的计算数据，此时被覆盖掉了因此需要从右往左计算 优化代码 12345678910111213141516171819202122class Solution { public int maxProfit2(int[] golds, int[] persons, int maxPerson) { int[] dp = new int[maxPerson + 1]; for (int i = 1; i &lt;= golds.length; i++) { // 需要从右往左计算 for (int j = maxPerson; j &gt;= 1; j--) { if (j &gt;= persons[i - 1]) { /** * 此处参考二位数组的方式 * dp[i-1][j]: i-1个金矿，j个工人 --&gt; 不挖 * dp[i - 1][j - persons[i - 1]]: i-1个金矿, j-persons[i-1]个工人 --&gt; 挖第i个金矿 */ dp[j] = Math.max(dp[j], dp[j - persons[i - 1]] + golds[i - 1]); } else { dp[j] = dp[j]; } } } return dp[maxPerson]; }}","link":"/2020/11/09/alg-dynamic-planning/"},{"title":"简单了解 Zookeeper","text":"本文简单介绍了一下 Zookeeper。 Zookeeper 的基本概念 Zookeeper 选举流程 常用的命令 ZookeeperZookeeper 的作用Zookeeper 的使用场景： 集群管理：容错、负载均衡 如 Dubbo 使用 Zookeeper 实现集群的服务发现 配置文件的集中管理 如将集群的节点原信息放到 Zookeeper 的数据节点上 集群的入口 最常用的使用场景是用于担任服务生产者和消费者的注册中心（提供发布订阅服务），服务生产者将自己注册到 Zookeeper，消费者订阅Zookeeper 的节点获取服务提供者列表 Zookeeper 集群需要有奇数个节点，原因是选举集群需要至少有 n/2 个节点投票选中 Leadeer2n 和 2n-1 个节点的容忍度都是 n-1 Zookeeper 的数据模型ZNode(数据节点) 介绍 ZNode 是 Zookeeper 中数据的最小单位，每个 ZNode 都可以保存数据，同时还可以有子节点，类似于 Unix文件路径 ZNode(数据节点) 结构每个 ZNode 由2部分组成： stat: 状态信息 data: 数据内容 Stat 类 1234567891011cZxid = 0x8 # 节点被创建时的事务IDctime = Fri Sep 18 15:16:27 CST 2020 # 节点被创建时间mZxid = 0x8 # 节点最后一次被更新时的事务IDmtime = Fri Sep 18 15:16:27 CST 2020 # 节点最后一次被更新时间pZxid = 0x8 # 节点的【子节点列表】最后一次被修改的事务ID，cversion = 0 # 子节点的版本号dataVersion = 0 # 数据节点的版本号aclVersion = 0 # 节点的ACL版本号ephemeralOwner = 0x0 # 创建该临时节点的会话的 sessionIDdataLength = 14 # 数据内容的长度numChildren = 0 # 节点的子节点个数 Zookeeper 的一些概念重要概念总结 Zookeeper 本身是一个分布式程序 为了保证高可用，最好以集群方式部署 Zookeeper，保证集群大部分机器可用的情况下 Zookeeper 本身仍然可用 Zookeeper 的数据保存在内存中，保证了高吞吐量和低延迟，但是不能保存大量配置数据 Zookeeper 是高性能的，在读多写少的情况下性能很高，在写多的情况下因为需要同步服务器间的状态会影响到性能 Zookeeper 有临时节点的概念，当创建节点的客户端保持活动时，瞬时节点就一直存在，当会话终止时，瞬时节点被删除。持久节点指的是一旦节点创建后除非主动移除，否则一直保存在 Zookeeper 上 Zookeeper 底层其实只提供两个功能：管理（存储、读取）用户程序提交的数据；为用户程序提供数据节点监听的服务 会话（Session） Session 指的是 Zookeeper 服务端与客户端的会话，当客户端与服务端建立起一个 TCP 长连接时，客户端会话的生命周期就开始了 客户端会话需要通过心跳机制保持会话的有效性，当超过 sessionTimeout 配置的时间没收到心跳包时，会话将失效（连接任意一台服务器发送心跳即可） 客户端会话创建前，服务端会为客户端分配一个全局唯一 sessionID，许多与会话有关的运行机制都是依赖于这个 sessionID 的 ZNodeZNode 时 Zookeeper 中的数据存储单元，每个 ZNode 都可以有子节点，类似于 Unix 树结构；ZNode 上会保存自己的数据内容，同时还会保存一系列属性信息； 永久节点被创建后除非主动移除，否则一直存在 临时节点当会话失效时就会销毁 SEQUENTIAL 属性可以让节点创建时自动在节点名后面追加一个整数数字，这种节点可以用来注册服务列表 版本每个 ZNode 都会维护一个 Stat 数据，记录了 dataVersion = 0 # 数据节点的版本号 cversion = 0 # 子节点的版本号 aclVersion = 0 # 节点的ACL版本号 Watcher事件监听器时 Zookeeper 中的一个重要特性，允许用户在指定的节点上注册 Watcher，当一些特定的事件触发时，服务端会将事件通知到感兴趣的客户端上，这是实现分布式协调服务的重要特性。 ACLZookeeper 使用 ACL(AccessControlLists) 策略来进行权限控制，类似于Unix文件系统的权限控制。Zookeeper 定义了如下5中权限： CREATE: 创建子节点权限 READ: 获取节点数据和子节点列表权限 WRITE: 更新节点数据权限 DELETE: 删除子节点权限 ADMIN: 设置节点 ACL 权限 Zookeeper 的角色Leader: 领导者 事务请求的唯一调度和处理者，保证集群事务处理的顺序性 集群内部各服务器的调度者 Follower: 跟随者 处理客户端非事务请求，转发事务请求给Leader服务器 参与事务请求Proposal的投票 参与Leader选举的投票 Observer: 观察者 处理客户端非事务请求，转发事务请求给Leader服务器 相比于Follower的区别是不参与投票 Zookeeper Leader 恢复模式 Leader election(选举阶段): 节点在一开始都处于选举阶段，只要一个节点得到半数票数，就可以当选准Leader DIscovery(发现阶段): Followers 跟准Leader 进行通信，同步 Followers最近接收的事务提议 Synchronization(同步阶段): 利用准Leader前一阶段获得的最新提议历史，同步集群中所有的副本，同步完成后准Leader才会成为真正的Leader Broadcadt(广播阶段): Zookeeper 集群正式对外提供服务，并且Leader可以进行消息广播，有新节点加入时，还需要对新节点进行同步。 ZAB协议&amp;Paxos算法Zookeeper支持的选举算法 基于UDP的LeaderElection 基于UDP的FastLeaderElection 基于UDP和认证的FastLeaderElection 基于TCP的FastLeaderElection FastLeaderElection 原理 myid每个 Zookeeper 服务器都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含了整个 Zookeeper 集群唯一的ID(整数)在配置文件中，其ID与hostname必须一一对应 zxid用于标识每一次更新操作的 Proposal ID，为了保证顺序性，zxid 必须单调递增Zookeeper 使用64位的数来表示，高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加1；低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置，这样保证了zxid的全局递增性 服务器状态 LOOKING: 不确定Leader状态，该状态下服务器认为集群中还没有Leader，会发起Leader选举 FOLLOWING: 跟随者状态，标识当前服务器是跟随者，并且知道它的Leader是谁 LEADING: 领导者状态，标识当前服务器是Leader，它会维护与Follower的心跳 OBSERVING: 观察者状态，标识当前服务器是观察者角色，不参与选举和集群写操作的投票 选票数据结构 logicClock: 每个服务器会维护一个自增的整数，标识这是该服务器发起的第几轮投票 state: 当前服务器状态 self_id: 当前服务器的myid self_zxid: 当前服务器上所保存的最大的zxid vote_id: 被推举的服务器的myid vote_zxid: 被推举的服务器上所保存的最大的zxid 投票流程 自增选举序列 每次选举服务器都会对logicClock进行自增 初始化选票 清空票箱 发送初始选 每个服务器通过广播将选票投给自己 接收外部选票 服务器尝试送外部获取选票，并计入自己的票箱 判断选举轮次 外部选票的logicClock大于自己的logicClock，说明服务器的选举轮次落后于其他服务器，立即清空票箱，并将自己的logicClock更新为收到的logicClock然后对比自己之前的投票与收到的选票以确定是否需要变更自己的投票，最终将自己的投票广播出去外部投票logicClock小于自己的logicClock，则忽略；如果相等，则进行选票PK 选票PK 基于(self_id, self_zxid)与(vote_id, vote_zxid)对比如果logicClock一致，则对比zxid，更新为较大者，广播出去如果zxid相同，则对比myid，更新为较大者，广播较大者的投票，并且广播出去如果自己就是较大者则忽略。 统计选票 如果过半服务器认可自己的投票，则终止投票，否则继续接收其他服务器的投票 更新服务器状态 若过半投票投给了自己，则更新服务器状态为LEADING，否则更新状态为FOLLOWING 集群启动领导选举按照投票流程投票，先投给自己，知道确定Leader Follower 重启选举启动进入LOOKING状态，发起投票投给自己，集群服务器返回自己的状态和选票，Follower发现Leader服务器，将自己的状态更新为FOLLOWING Leader 重启选举发起投票，投票给自己，依据zxid和myid确定选票，选出新的Leader旧的 Leader 恢复后，进入 LOOKING 状态并发起新一轮的领导选举，其他步骤遵循 Follower 重启选举 Zookeeper 语义保证 顺序性：客户端发起的更新会按照顺序应用到 Zookeeper 上 原子性：更新操作要么成功要么失败，不会出现中间状态 单一系统镜像：一个客户端无论连接哪个服务器都会看到完全一样的系统镜像，写操作并不保证所有的 Follower 立即确认，因此通过 Follower 并不能保证读到最新的数据，如果一定要读取到最新的数据，读取之前可调用 sync() 方法 可靠性：一个更新操作一旦被接受即不会意外丢失，除非被其他更新操作覆盖 最终一致性：写操作最终（而非立即）会对客户端可见 Zookeeper Watch 机制所有对 Zookeeper 的读操作，都可附带一个 Watch，一旦数据发生变化，该 Watch 即被触发Watch 机制的特点： 主动通知：Watch 被处罚时，Zookeeper 服务器将主动推送更新给客户端 一次性：Watch 只会被触发一次，如需再次触发需要重新注册 Watch 可见性：Watch 通知收到前不可能看到更新后的数据，即 更新通知先于更新结果 顺序性：如果多个更新触发了 Watch，那 Watch 被触发的顺序与更新顺序一致。 分布式锁与领导选举关键点 最多一个获取锁 / 成为 Leader 锁重入 / 确认自己是 Leader 释放锁 / 放弃领导权 感知锁释放 / 领导权的放弃 非公平领导选举 选主过程 多个客户端同时向 Zookeeper 集群注册 Ephemeral 且 Non-Sequence 类型的节点，路径为同一路径，只有一个客户端能创建成功 放弃领导权 如果 Leader 进程宕机，则与之对应的 Session 也将结束，节点会自动删除，对于其他客户端而言 Leader 放弃了领导权 感知领导权的放弃 创建节点失败的客户端除了成为 Follower 还会向同一路径注册 Watch，当 Leader 放弃领导权时，该节点被删除，所有的 Follower 会收到通知。 重新选举 所有的 Follower 再次发起选主过程 公平领导选举相较于非公平领导选举，客户端创建 Sequence 节点，每个客户端向上一个 Sequence 节点注册 Watch，当第一个节点的客户端放弃领导权后，它的下一个节点对应客户端获得领导权 Zookeeper 常用命令123456789101112131415161718192021222324# 连接节点./zkCli.sh -server 127.0.0.1:2181# 查看帮助help# 创建节点create /node &quot;node data&quot;create /node1/node2 123# 更新节点set /node1/node2 &quot;set node data&quot;# 获取节点数据get /node1/node2# 查看子节点ls /node1# 查看节点状态stat /node1# 删除节点，删除的节点不能有子节点delete /node1","link":"/2020/11/17/zookeeper/"},{"title":"学习笔记 2020-11-16","text":"今天简单学习了 Spring 和 NettySpring Spring 的基本特性和模块，IoC 和 AOP Spring Bean 的生命周期 Spring MVC 的流程 Spring 事务 Netty Netty 的组件 Netty 初始化方式 Netty 长连接和心跳 Netty 沾包/拆包解决方式 SpringSpring 特征 核心技术：DI、AOP、事件(Events)、资源、i18n、验证、数据绑定、类型转换，SpEL 测试：模拟对象、TestContext测试、Spring MVC测试、WebTestClient 数据访问：事务、DAO支持、JDBC、ORM、编组XML Web支持：Spring MVC, Spring WebFlux 集成：远程处理、JMS、JCA、JMX、电子邮件、任务、调度、缓存 语言：Kotlin、Groovy、动态语言 Spring 模块 Spring Core: Spring 基础，其他模块的底层依赖，主要提供 IOC 依赖注入支持 Spring Aspects: 提供和 AspectJ 的集成支持 Spring AOP: 提供面向切面的编程实现 Spring JDBC: Java 数据库连接 Spring JMS: Java 消息服务 Spring ORM: 为 Hibernate 等 ORM 框架提供支持 Spring Web: 为创建 Web 应用程序提供支持 Spring Test: 提供了对 Junit 和 TestNG 测试的支持 对 Spring 的 IoC 和 AOP 的理解IoC(Inverse of Control: 控制反转)IoC 是一种设计思想，将原本在程序中手动创建对象的控制权交由容器来管理。Spring 中实现 IoC 的方式是维护一个 IoC 容器，实际上是一个Map，如果是单例对象，本质是在 DefaultSingletonBeanRegistry.singletonObjects 中获取 Bean 实例。使用 IoC 后，可以将依赖注入交给 IoC 容器管理，不再需要从上到下的创建依赖对象 DIP: (Dependency Inversion Principle) 依赖导致原则 IoC: (Inverse of Control) 控制反转 DI: (Dependency Injection) 依赖注入 三者的关系如下： Spring IoC 的初始化过程： AOP(Aspect-Oriented Programming:面向切面编程)面向切面编程，能够将与业务无关的代码却模块间共用的代码封装起来，减少系统的重复代码，降低模块耦合性。如：事务管理、权限管理、日志管理等Spring 的 AOP 只支持方法增强，使用的代理模式为： 面向接口：JDK代理，CGLib代理(继承实现) 面向类：CGLib代理 Spring AOP 和 AspectJ Spring AOP 属于运行时增强/织入 Spring AOP 使用了 AspectJ 的一些注解，使用 AspectJ 来定义切面，使用 PointCut 定义切入点，使用 Advice 来增强处理但不是使用的 AspectJ 语法，而是使用的JDK动态代理或CGLib AspectJ 属于编译时增强/织入 AOP失效的原因Spring AOP 在以下场景会失效 没有被 Spring 管理 bean 自身调用自身，通过 this. 调用 方法不是 public 方法 Spring Bean 的作用域Spring Bean包含以下作用域 singleton: 单例 prototype: 每次请求创建一个对象 request: 每次HTTP请求创建一个对象 session: 每次HTTP会话创建一个对象 global-session: 全局session作用域，仅在portlet应用中有用，Spring5已经废弃 Spring获取Bean的流程 获取BeanName，如果传入的是classType，则从DefaultListableBeanFactory.allBeanNamesByType 中获取对应的beanName 根据beanName在DefaultSingletonBeanRegistry.singletonObjects中查找单例Bean 如果找到了则返回，如果没有找到则查询 BeanDefinition 获取bean的依赖，提前先创建依赖 如果是prototype，创建完bean后直接返回 如果是singleton，创建完bean后回调，将bean放入singletonObjects 和 registeredSingletons 缓存中 单例Bean的线程安全 尽量避免使用全局变量 使用ThreadLocal变量隔离线程 Spring Bean的生命周期 Bean 容器找到配置文件中 BeanDefinition 利用 Java Reflection API 创建一个 Bean 的实例 如果涉及一些属性值，则利用 setXX() 方法设置属性 如果 Bean 实现了 BeanNameAware 接口，则调用 setBeanName() 方法传入 Bean 的名称 如果 Bean 实现了 BeanClassLoaderAware 接口，则调用 setBeanClassLoader() 方法传入 ClassLoader 对象实例 如果 Bean 实现了 BeanFactoryAware 接口，则调用 setBeanFactory() 方法传入 BeanFactory 对象实例 如果 Bean 实现了其他的 *Aware 接口，则调用相应的方法 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，则执行 postProcessBeforeIntialization() 方法 如果 Bean 实现了 InitalizingBean 接口，则调用 afterPropertiesSet() 方法 如果 Bean 配置文件定义了 init-method 方法，则执行指定的方法 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，则执行 postProcessAfterInitialization() 方法 销毁：如果实现了 DisposableBean 接口，则调用 destory() 方法 销毁：如果 Bean 配置文件定义了 destory-method 方法，则执行指定的方法 图示： 中文版： Spring MVC对于 Sping MVC 的理解Spring 分离了控制器、模型对象、分派器以及处理程序对象的角色，分离后更易定制。Spring MVC 框架主要有 DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。 Spring MVC 工作原理 主要流程： 客户端发起请求，直接请求到 DispatcherServlet DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler此时返回的是 executionChain 包含 HandlerInterceptor 解析到对应的 Handler（通常所说的Controller）后，开始由 HandlerAdapter 适配器处理先执行 HandlerInterceptor 的 applyPreHandle() 方法然后执行 HandlerAdapter 的 handle() 方法最后执行 HandlerInterceptor 的 applyPostHandle() 方法 HandlerAdapter 调用真正的处理器处理请求，并处理相应的业务逻辑，处理完成后返回一个 ModelAndView 对象Model 对应的数据对象，View 对应逻辑视图 ViewResolver 根据逻辑视图解析出实际的视图 DispatcherServlet 将 Model 传给实际的 View 渲染 DispatcherServlet 将渲染结果返回给客户端 Spring 事务Spring 事务简介Spring 事务分为： 声明式事务：XML配置或注解 编程式事务：硬编码 Spring 事务的隔离级别Spring 事务的隔离级别在 TransactionDefinition 中定义 ISOLATION_DEFAULT: 数据库默认 MySQL 默认是 REPATABLE_READOracle 默认是 READ_COMMITED ISOLATION_READ_UNCOMMITED: 读未提交 ISOLATION_READ_COMMITED: 读已提交 ISOLATION_REPATABLE_READ: 可重复读 ISOLATION_SERIALIZABLE: 串行化 Spring 事务的传播类型支持当前事务 PROPAGATION_REQUIRED: 如果当前存在事务则加入，不存在则新建 PROPAGATION_SUPPORTS: 如果当前存在事务则加入，不存在则以非事务方式运行 PROPAGATION_MANDATORY: 如果当前存在事务则加入，不存在则抛异常 不支持当前事务 PROPAGATION_REQUIRES_NEW: 新建一个事务，如果当前存在事务则挂起 PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务则挂起 PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务则抛异常 其他情况 PROPAGATION_NESTED: 如果当前存在事务，则新建一个嵌套事务运行，不存在则新建一个事务 事务回滚当在注解或者XML文件中配置了 rollbackFor=Exception.class 属性，则当抛出 Exception 异常或其子类异常时会回滚事务如果没有配置，则默认是 rollbackFor=RuntimeException.class Spring 事务失效因为 Spring 事务是基于AOP实现的，因此在 AOP 失效的场景下 Spring AOP 失效的场景下会失效。除此以外还有以下几种情况： 未配置事务管理器 定义在非 public 方法上 @Transactinal 注解只支持 public 方法如果要在非 public 方法上使用注解，需要将代理模式改成 aspectj 数据库不支持 异常被吃掉了 异常类型错误 NettyBIO、NIO、AIO 的区别 BIO: 阻塞IO，数据的读取写入必须阻塞在一个线程内，等待其完成 NIO: 非阻塞IO，同步非阻塞的IO模型，提供 Channel, Selector, Buffer 等抽象 AIO: 异步IO，基于事件通知和回调机制实现 为什么要使用 Netty 而不是 Java 自带的 NIO API Netty 具有统一的 API，支持阻塞、非阻塞传输模型 Netty 简单而强大的线程模型，比 Java 原生 NIO API 具有更高的吞吐量和更低的资源消耗 自带编解码器解决 TCP 沾包 / 拆包问题 原生支持多种协议栈 真正支持无连接数据包套接字（UDP）支持 有完整的 SSL/TLS 和 StartTLS 支持 Netty 的应用场景 HTTP 服务器 RPC 框架的网络通信工具 即时聊天系统 消息推送系统 Netty 的核心组件 ByteBuf: 字节容器 可以看作对 Java NIO 提供的 ByteBuffer 的抽象 Boostrap: 客户端启动引导类 ServerBootstrap: 服务端启动引导类 Channel: 网络操作抽象类 通过 Channel 可以进行 IO 操作，一旦建立连接，就会创建一个 Channel 与该客户端绑定 EventLoop: 事件循环 用于处理连接生命周期中所发生的事件监听网络事件，并调用事件处理器进行相关的IO操作 EventLoopGroup: 包含多个 EventLoop，为每个 Channel 分配一个 EventLoop ChannelHandler: 消息处理器 具体的消息处理器，主要负责处理接收和发送的数据 ChannelPipline: 消息对象链表 通过 ChannelHandlerContext 来间接管理 ChannelHandler ChannelFuture: 操作执行结果 NIO 所有的IO操作都是异步的，可以通过 ChannelFuture 接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或失败时会自动触发回调。可以通过 ChannelFuture 的 channel() 方法获取相关联的 Channel可以通过 ChannelFuture 的 sync() 方法将异步编程同步化 对 Bootstrap 和 ServerBootstrap 的了解 Bootstrap: 需要分配一个 EventLoopGroup通过 connect() 方法连接服务端，也能使用 bind() 方法绑定本地端口作为 UDP 通信的一段 ServerBootstrap 需要分配两个 EventLoopGroup，一个用于连接，一个用于具体的处理通过 bind() 方法绑定本地端口作为服务端 NioEventLoopGroup 默认线程数NioEventLoopGroup 无参构造方法线程数为0，最终调用到父类 MultithreadEventExecutorGroup 的下面这个构造方法 123protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) { super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);} DEFAULT_EVENT_LOOP_THREADS 是在一个静态变量，初始化代码如下： 1private static final int DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); 可以看出默认线程数按照以下规则获取 获取环境变量中的 io.netty.eventLoopThreads 如果没获取到则取 CUP核心数*2 如果上面两步获取到的线程数小于1，则取1 Netty 线程模型 单线程模型：Acceptor线程和worker线程是同一个线程 多线程模型：一个Acceptor线程负责接受连接，多个worker线程负责读取/写入数据和处理具体的逻辑 主从多线程模型：多个Acceptor线程负责接受连接，将连接绑定到一个worker线程 Netty 初始化流程服务端： 创建两个 EventLoopGroup, bossGroup 和 workerGroup 实例化 ServerBootstrap 调用 ServerBootstrap.group() 方法指定线程组 调用 ServerBootstrap.channel() 方法指定 IO 模型 调用 ServerBootstrap.childHandler() 方法指定工作线程的 handler 链，此处是创建了一个 ChannelInitializer 对象用于初始化 ChannelHandler 链 调用 ServerBootstrap.bind() 方法绑定本地端口，返回一个 ChannelFuture 可以调用 ChannelFuture.sync() 将异步转成同步，获取一个 ChannelFuture 调用 ChannelFuture.channel().closeFuture().sync() 可以同步监听 Channel 关闭事件 客户端：与服务端初始化类似 创建一个 EventLoopGroup, workerGroup 实例化 Bootstrap 调用 Bootstrap.group() 方法指定线程组 调用 Bootstrap.channel() 方法指定 IO 模型 调用 Bootstrap.handler() 方法指定工作线程的 handler 链，此处是创建了一个 ChannelInitializer 对象用于初始化 ChannelHandler 链 调用 Bootstrap.connect() 方法连接服务端，返回一个 ChannelFuture 可以调用 ChannelPromise.sync() 将异步转成同步，获取一个 ChannelFuture 调用 ChannelFuture.channel().closeFuture().sync() 可以同步监听 Channel 关闭事件 Netty 解决 TCP 沾包/拆包为什么会出现 TCP 沾包/拆包TCP 是无界的数据流，发送端将需要发送的数据发送到缓冲区，当缓冲区满的时候数据包才会真正被发送出去，同理接收端也是等待缓冲区满后才会读取数据。当发送的数据大于缓冲区大小时，就会出现缓冲区中只有一部分数据，即发生了拆包当发送的数据小于缓冲区大小时，缓冲区中可能包含多个数据包的数据，即发生了沾包 WebSocketWebSocket 是根据 RCF6455 规范实现的。每次发送或者接收的帧报文中，都会有定义协议的一些信息，例如头部大小，数据大小，以及帧类型，标识位等信息。WebSocket 的出现可以认为是专门为了解决沾包 / 拆包问题 Netty 解决沾包 / 拆包问题Netty 中使用了多种 Decoder 解决沾包拆包问题 LineBasedFrameDecoder: 发送数据包时以换行符作为分隔 DelimiterBasedFrameDecoder: 自定义分隔符 FixedLengthFrameDecoder: 固定长度解码器 LengthFieldFrameDecoder: 包含数据包长度字段的解码器 自定义解码器如使用 Protostuff, Hession2, json 序列化专门针对 Java 语言的：Kryo，FST 等跨语言的：Protostuff（基于 protobuf 发展而来），ProtoBuf，Thrift，Avro，MsgPack 等 Netty 长连接和心跳机制长连接 短连接：建立连接发送完数据后关闭连接 长连接：建立连接发送完数据后继续保持连接，后续的读写操作可以继续使用这个连接，省去TCP建立连接的资源消耗，适用于需要频繁建立连接的场景 心跳机制在没有心跳机制的情况下，客户端和服务端之间没有一段时间没有发送数据时，无法感知对方是否已经掉线使用心跳机制，当客户端和服务端一段时间没有交互，既处于idle状态时，客户端发送一个特殊的报文给服务端，服务端接收到报文后立即返回一个特殊的报文，此既一个 PING-PONG 交互，以此来确保TCP连接的有效性TCP 协议自带有长连接机制，即 TCP的 SO_KEEPALIVE 选项，但是不够灵活，因此一般都是在应用层协议上实现自定义心跳机制Netty 中心跳机制的核心类时: IdleStateHandler Netty 的零拷贝问题 使用 Netty 提供的 CompositeByteBuf 类，可以将多个 ByteBuf 类合并成一个逻辑上的 ByteBuf，避免 ByteBuf 间的拷贝 ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解成多个共享同一存储区域的 ByteBuf 避免了内存拷贝 通过 FileRegion 包装的 FileRegion.transferTo 实现文件传输，可以直接将文件缓冲区的数据发送到目标 Channel，避免了通过while循环方式导致的内存拷贝问题。","link":"/2020/11/16/note-2020-11-16/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"垃圾收集","slug":"垃圾收集","link":"/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java线程","slug":"Java线程","link":"/tags/Java%E7%BA%BF%E7%A8%8B/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Zookeeper","slug":"Zookeeper","link":"/tags/Zookeeper/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"}]}