{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q: 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true 输入 [1 -&gt; 2 -&gt; 1], 输出true 输入 [1 -&gt; 2], 输出false 输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q: 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q: 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"},{"title":"学习笔记 2020-10-30","text":"今天回顾了一下集合类和 GC Root 有两处需要学习的知识点：HashMap 的红黑树转换方法，ConcurrentHashMap.helpTransfer() 的原理 算法题是来自于力扣网的 123. 买卖股票的最佳时机 III 难度：困难 集合类HashMap DEFAULT_INITIAL_CAPACITY ( 1 &lt;&lt; 4 ) : 默认初始化容量 16 MAXIMUM_CAPACITY ( 1 &lt;&lt; 30 ) : 最大容量 1 &lt;&lt; 30 DEFAULT_LOAD_FACTOR : 默认负载因子 0.75 TREEIFY_THRESHOLD : 链表转红黑树阈值 8 UNTREEIFY_THRESHOLD : 红黑树转链表阈值 6 MIN_TREEIFY_CAPACITY : 链表转红黑树最小Node数组大小 64 红黑树树转链表会发生在一下两处 数组扩容，红黑树拆分后，节点数小于 UNTREEIFY_THRESHOLD 删除节点后，root, root.right, root.left, root.left.left 任何一个为 null HashMap 线程不安全的原因 JDK 1.7 HashMap 扩容的时候，链表的节点顺序会反转，因此多线程操作可能出现环，get 操作的时候会出现死循环，也有可能丢失数据 JDK 1.8 HashMap 扩容的时候，链表节点不反转，不会出现环，但是可能丢失数据 未明确的知识点？ HashMap 红黑树的转换原理 ConcurrentHashMap helpTransfer() 的原理 其它集合类 List : ArrayList , LinkedList , Vector Set : HashSet , LinkedHashSet , TreeSet Map: HashMap , LinkedHashMap , TreeMap , Hashtable 进程&amp;线程进程 是程序运行的基本单位，线程 是系统调度的基本单位进程 拥有独立的内存区域，线程 的内存区域存在 独享 和 共享 （栈、堆） new Thread() 创建了一个线程，线程进入 NEW 状态thread.start() 启动线程并使线程进入就绪状态 GC RootGC Root 是垃圾回收期标记存活对象的起点 GC Root 有哪些 Class 由系统类加载器加载的对象 Thread 激活状态的线程 Stack Local 栈中的对象 JNI Local JNI栈中的对象 JNI Global JNI中的全局对象 Monitor Used 正在被用于同步的各种锁对象 Held By JVM JVM自身持有的对象，比如系统类加载器等 算法题今天算法题来自力扣网 123. 买卖股票的最佳时机 III 难度：困难 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 思考 可以看到，对于第一次买卖： 要获取从第 0 天开始，到第 i 天内，能获取到的最大利润 需要记录前 i - 1 天最小的买入价 min 使用第 i 天的买入价 - min，得到第 i 天的利润 使用上一步的利润与第 i - 1 天的利润相比，选择较大的一个作为第 i 天的利润 对于第二次买卖： 有两种思路： 从第 n - 1 天开始计算第 n - 1 天到第 1天可以获得的最大利润 第二个思路还没看太明白，参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/10208","link":"/2020/10/30/note-2020-10-30/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java线程","slug":"Java线程","link":"/tags/Java%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}