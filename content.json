{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"动态规划问题","text":"动态规划：问题的最优解如果可以由子问题的最优解推导得到，则可以先求子问题的最优解，再构造原问题的最优解。若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题最终求解。 本文内容包含了几个常见的动态规划问题 金矿问题：简单动态规划 金矿问题国王有n个金矿和w个工人，每个金矿的黄金储量和需要的工人数不同。每个金矿要么不挖，要么全挖，不能只派一部分工人或者只挖一部分。要求计算出国王能挖出的最多黄金和选择挖哪几座金矿？ 如有5个金矿，10个工人，每个金矿的产量和需要的工人数如下：产量 | 人数 | -200kg | 3人300kg | 4人350kg | 3人400kg | 5人500kg | 5人 思路 思路1：贪心算法的思想 计算每个金矿的性价比，按照性价比的从高到低选择挖的金矿能用简单计算出局部最优解，但是局部最优解不一定是全局最优解 思路2：动态规划的思想 设金矿总数 n, 工人总数 w, 每个金矿产量 g[n], 需要的人数 p[n]第 n 个金矿要么挖，要么不挖，那么对于前 n-1 个金矿，可以消耗的工人就是 w 或 w - p[n]如果挖，f(n, w) = f(n-1, w - p[n]) + g[n]如果不挖，f(n, w) = f(n-1, w)因此可以得到状态转移方程 f(n, w) = max(f(n-1, w), f(n-1, w-p[n]) + g[n]) 代码实现 12345678910111213141516171819202122232425class Solution { public int maxProfit(int[] golds, int[] persons, int maxPerson) { // 建立dp数组 int[][] dp = new int[golds.length + 1][maxPerson + 1]; // 遍历金矿 for (int i = 1; i &lt;= golds.length; i++) { // 遍历1-maxPerson个工人 for (int j = 1; j &lt;= maxPerson; j++) { if (j &gt;= persons[i - 1]) { /** * dp[i-1][j]: i-1个金矿，j个工人 --&gt; 不挖 * dp[i - 1][j - persons[i - 1]]: i-1个金矿, j-persons[i-1]个工人 --&gt; 挖第i个金矿 */ dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - persons[i - 1]] + golds[i - 1]); } else { // 人手不足，取第i-1个金矿的收益 dp[i][j] = dp[i - 1][j]; } } } // 返回dp数组的最后一个 return dp[golds.length][maxPerson]; }} 上面一种算法的dp数组使用的二位数组，实际计算中每次只取上一行数据计算，因此可以简化成一维数组简化成一维数组后，需要注意不能覆盖了未参与计算的值，如:dp[i] = dp[i-1], dp[i] 应该作为 dp[i+1] 的计算数据，此时被覆盖掉了因此需要从右往左计算 优化代码 12345678910111213141516171819202122class Solution { public int maxProfit2(int[] golds, int[] persons, int maxPerson) { int[] dp = new int[maxPerson + 1]; for (int i = 1; i &lt;= golds.length; i++) { // 需要从右往左计算 for (int j = maxPerson; j &gt;= 1; j--) { if (j &gt;= persons[i - 1]) { /** * 此处参考二位数组的方式 * dp[i-1][j]: i-1个金矿，j个工人 --&gt; 不挖 * dp[i - 1][j - persons[i - 1]]: i-1个金矿, j-persons[i-1]个工人 --&gt; 挖第i个金矿 */ dp[j] = Math.max(dp[j], dp[j - persons[i - 1]] + golds[i - 1]); } else { dp[j] = dp[j]; } } } return dp[maxPerson]; }}","link":"/2020/11/09/alg-dynamic-planning/"},{"title":"两个数最大公约数","text":"有两个正整数，求两个数的最大公约数。这个问题有几种常见的算法 暴力破解 辗转相除法 更相减损法 在本文中将这个问题做一些探究 以下内容为了精简代码，均认定代码两个参数 big &gt;= small 暴力破解暴力破解既循环遍历，判断是否为两个数的公约数这里可以有些推论： 一个数 n 的最大约数是其本身，因此这个数第二大的约数必定 &lt;= n / 2 遍历公约数的时候可以从 min / 2 开始遍历 以下代码 123456789101112131415161718192021222324252627282930313233public int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } for (int i = small / 2; i &gt; 1; i++) { if (big % i == 0 &amp;&amp; small % i == 0) { return i; } } return 1;}``` 这个方法很直观明了，缺点是当两个数相差很小，如 10000, 10001，需要计算的次数很多 ## 辗转相除法**辗转相除法** 又名 欧几里得算法，可追溯到公元前300年 该算法的思想基于一条定理：如果两个正整数 a 和 b (a &gt; b)，它们的最大公约数等于 a / b 的余数与 b 之间的最大公约数 假设最小公约数是 q，那么 a = m * q, b = n * q a = (m - i * n) * q + (i * n) * q = (m - i * n) * q + i * (n * q) 当 (m - i * n) * q &lt; n 时，a / b 的商为：i， 余数为：(m - i * n) * q **代码实现**```javapublic int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } return getGreatestCommonDivisor(small, big % small);} 这个算法计算次数很少，存在的缺点是当两个数都很大时，取余操作性能比较差 更相减损法更相减损法 来自于《九章算术》基本思路是两个数的最大公约数是两个数只差与较小的数的最大公约数从本质上来看，这个算法的思路与辗转相除法类似，但是这个算法使用减法运算大大降低了计算难度计算次数就比辗转相除法多一些 代码实现 123456public int getGreatestCommonDivisor(int big, int small) { if (big % small == 0) { return small; } return getGreatestCommonDivisor(small, big - small);} 位移运算+更相减损法两个整数 a 和 b 存在三种场景 a 和 b 均为偶数：此时 f(a, b) = 2 * f(a/2, b/2) = 2 * f(a&gt;&gt;1, b&gt;&gt;1) a 为奇数，b 为偶数：f(a, b) = f(a, b/2) = f(a, b&gt;&gt;1) a 和 b 均为奇数：先使用更相减损法，f(a,b) = f(b, a-b)，此时已经符合场景2，可以继续使用场景2的方式计算 代码实现 12345678910111213141516171819202122public int getGreatestCommonDivisor(int a, int b) { if (a == b) { return a; } // &amp;1 代替余2, &lt;&lt;1 代替乘2 if ((a &amp; 1 == 0) &amp;&amp; (b &amp; 1 == 0)) { return getGreatestCommonDivisor(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; } else if ((a &amp; 1 == 0) &amp;&amp; (b &amp; 1 != 0)) { return getGreatestCommonDivisor(a &gt;&gt; 1, b); } else if ((a &amp; 1 != 0) &amp;&amp; (b &amp; 1 == 0)) { return getGreatestCommonDivisor(a, b &gt;&gt; 1); } else { if (a &lt; b) { // 0^0=0, 0^1=1, 1^0=1, 1^1=0 // a ^ b ^ b == a a = a ^ b; b = a ^ b; a = a ^ b; } return getGreatestCommonDivisor(a - b, b); }} 这种方式极大简化了辗转相除法的除法运算，也减少了更相减损法的计算次数，效率比较高 补充一个算法 判断一个数是否为2的整数次幂除了传统的 /2 计算外，可以使用位运算优化如： 16 = 1000016 - 1 = 15 = 111110000 &amp; 1111 == 0 因此这个问题可以简化为判断 1return n &amp; (n-1) == 0;","link":"/2020/11/05/alg-greatest-common-divisor/"},{"title":"贪心算法","text":"贪心算法：依次求局部最优解，最终得到整体最优解的思想 本文内容包含了几个常见的贪心算法问题 一个整数删除 k 个数字后的最小值 一个整数删除 k 个数字后的最小值对于这个问题，需要考虑怎么确定 k 个数字的位置 思路1: 删除最大的几个数字 在一些情况下，这个思路可行，如: 54321(删除2个), 75310(删除2个)但是在很多非递增的情况，不可行，如：52130，删除5,3后的值为210，并不是最小值130 思路2: 每次删除1个数字，删除k次 这个思路将删除 k 个数字变换成求删除1个数字的最小值计算局部的最优解，最终得到整体的最优解 对于思路2，使用的既是贪心算法的思想，有局部最优解得到整体最优解那么，怎么确定需要删除的1个数字呢？ 对于数字序列 5,4: 删除 5 能得到最小值 对于数字序列 5,6: 删除 6 能得到最小值可以发现当序列为顺序时，删除前面的数字能得到最小值，当序列为倒序时，删除后面的数字能得到最小值 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution { public String minValue(String num, int k) { for (int i = 0; i &lt; k; i++) { // 标记是否分隔字符串 boolean cut = false; for (int j = 1; j &lt; num.length(); j++) { // 倒序，删除前面的数字 if (num.charAt(j - 1) &gt; num.charAt(j)) { num = num.substring(0, j - 1) + num.substring(j); cut = true; break; } } // 未找到倒序，删除最后一个数字 if (!cut) { num = num.substring(0, num.length() - 1); } // 删完了，break if (num.length() == 0) { return &quot;0&quot;; } } if (num.length() == 0) { return &quot;0&quot;; } return Integer.valueOf(num).toString(); }}``` 上面的算法已经能解决获取最小值的问题，此时思考下这个算法的复杂度 设整数长度为 n，删除 k 个数字，则时间复杂度为 `O(kn)` 因为要不断的 substring()，效率不高 可以联想栈的结构，当一个栈顶的数字比要入栈的数字大时，让栈顶数字出栈，此时就认为是删除了一个数字 **优化代码**```javaclass Solution { public String minValue(String num, int k) { // 新长度 int newLen = num.length() - k; // 栈数组 char[] stack = new char[num.length()]; // 栈顶索引 int top = 0; for (int i = 0; i &lt; num.length(); i++) { char c = num.charAt(i); // 栈不为空，栈顶元素大于c，还有删除元素 while (top &gt; 0 &amp;&amp; stack[top - 1] &gt; c &amp;&amp; k &gt; 0) { top -= 1; k -= 1; } // 当前数字入栈 stack[top++] = c; } // 判断栈中第1个非0数字 int offset = 0; // 起始位置小于新长度，判断起始位置的字符 while (offset &lt; newLen &amp;&amp; stack[offset] == '0') { offset++; } // 剩余字符全是0，或没有剩余字符 if (offset == newLen) { return &quot;0&quot;; } // 取起始位置和newLen之间的字符 return new String(stack, offset, newLen - offset); }} 至此，这个算法将遍历整数作为外层，减少了计算次数，也避免了重复的 substring() 操作","link":"/2020/11/09/alg-greedy-algorithm/"},{"title":"数据结构 - 最小栈","text":"本文讲述怎么去实现一个栈，并且入栈、出栈、获取最小值的时间复杂度都是 O(1) 栈的实现栈可以使用数组或链表结构实现，在 Java 中的 Stack 类的实现使用的数组结构 一个元素数组 一个记录元素总数的变量当入栈时，设置 elementCount 索引位置的值为入栈元素值，elementCount++当出栈时，获取 elementCount - 1 索引位置元素的值，elementCount– 最小栈的实现方法1定义一个变量 min，每次入栈时与 min 比较大小，当小于 min 时，将值赋值给 min这个方法入栈时，能保证 getMin() 获取的值为最小值，但是如果最小值出栈，则无法知道下一个最小的元素 方法2定义一个辅助栈，入栈时将当前最小值入辅助栈推论1：当栈为空时，第一个入辅助栈的元素必定为栈底元素，可以保证辅助栈在栈不为空时始终有元素推论2：因为每次将最小的元素入辅助栈，所以辅助栈中最小的元素出栈后，栈顶的元素也必定是当前最小的推论3：如果有两个最小元素值相同，如果辅助栈只入栈第一个元素，那么当第二个元素出栈后获取新的栈顶元素不再是最小值，因此相同的最小元素也要入栈 代码实现 123456789101112131415161718192021private Stack&lt;Integer&gt; mainStack = new Stack&lt;&gt;();private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();public void push(int element) { mainStack.push(element); if (minStack.isEmpty() || element &lt;= minStack.peek()) { minStack.push(element); }}public int pop() { int element = mainStack.pop(); if (element.equals(minStack.peek())) { minStack.pop(); } return element;}public int getMin() { return minStack.peek();}","link":"/2020/11/05/datastruct-min-stack/"},{"title":"JVM 垃圾收集","text":"本文主要介绍 Java 堆的垃圾收集策略和一些常见的垃圾收集器 新生代垃圾收集新生代的垃圾回收一般采用复制算法，回收的过程如下： 将 Eden 和 S0 中存活的对象复制到 S1 中，对象年龄+1，当对象年龄到达阈值（默认: 15）时，对象将晋升到老年代 清空 Eden 内存区域，交换 S0 和 S1 区域 如果 S1 区域存放不下则使用分配担保机制直接进入老年代 对象晋升老年代的阈值可以通过 -XX:MaxTenuringThreshold 设置 老年代垃圾收集Minor GC 和 Full GC 新生代GC (Minor GC): 新生代发生的 GC，Minor GC 非常频繁，速度也比较快 老年代GC (Major GC / Full GC): 老年代的 GC，通常伴有至少一次 Minor GC （并非绝对），回收时间是 Minor GC 的10倍以上 垃圾回收算法 复制算法：将内存分为大小相同的两块，每次将存活的对象复制到另一块，再把使用的空间一次清理掉 标记-清除：先标记需要回收的对象，标记完成后一次清理掉需要回收的对象，会产生内存碎片 标记-整理：先标记需要回收的对象，再将存活对象向一端移动，完成后清除端边界以外的内存 垃圾收集器常见的垃圾收集器有： Serial, ParNew, Parallel Scavenge,CMS、G1 Serial使用单线程收集，新生代使用复制算法，老年代使用标记整理 ParNew使用多线程收集，其余和 Serial 一样，新生代使用复制算法，老年代使用标记整理 Parallel Scavenge关注吞吐量，可以通过一些参数指定需要优化的目标，垃圾收集器能自动优化-XX:MaxGCPauseMillis 最大暂停时间, 0以上/毫秒-XX:GCTimeRatio GC时间占总时间的比例, 0-100-XX:+UseAdptiveSizePolicy 根据性能监控信息，动态调整参数 Serial OldSerial 收集器的老年代版本，可作为 CMS 的后备收集器 Parallel OldParallel Scavenge 收集器的老年代版本，可作为 CMS 的后备收集器 CMSCMS（Concurrent Mark Sweep）是以获得最短停顿时间为目标的收集器优点：并发收集，停顿时间短缺点：会产生内存碎片，因此需要使用 Serial Old 或 Parallel Old 作为后备收集器 CMS 是一种用 标记-清除 算法的实现，分为四个步骤 初始标记：暂停所有线程，并记录与 GC Roots 直接相连的对象，很快并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象，同时记录用户线程更新的引用域重新标记：暂停用户线程，修正并发标记期间因为用户线程运行而导致标记产生变动的那一部分对象的标记记录，时间比初始标记长，远远比并发标记短并发清除：同时开启用户线程，对标记区域进行清除 G1Heap 被划分为一个个大小相等的不连续的内存区域(Region)每个 Region 都有一个分代角色: Eden, Survior, Old（old还有一种细分 humongous，用来存放大小超过 region 50%以上的巨型对象）每个 Region 的角色可以变更每个角色的数量没有强制的限定，默认年轻代占5% G1优先去执行大量对象可被回收的 Region，使用暂停可预测决定一次回收多少 RegionG1从多个 Region 中复制存活对象到1个 Region，同时整理-清除内存 TODO 待补充 如何判断对象可被回收？算法 引用计数给对象分配一个计数器，当被引用时计数器+1，使用完后计数器-1，当计数器为0时，对象不可能被引用 可达性分析可达性分析是从 GC Roots 往下搜索，当对象未被任一 GC Root 链引用到时，则证明对象不可用可被回收 GC Root可以作为 GC Roots 的对象 由 系统类加载器 (System Class Loader) 加载的对象 Thread - 活着的线程 Stack Local - Java 方法的local变量或参数 JNI Local - JNI 方法的local变量或参数 JNI Global - 全局 JNI 引用 Monitor Used - 用于同步的监控对象 Held by JVM - 由JVM GC 保留的对象 强引用、软引用、弱引用、虚引用 强引用：直接引用的对象 软引用：可有可无的对象，当内存不足时，会被回收 弱引用：可有可无的对象，生命周期比弱引用短，当发生GC是会被回收 虚引用：任何时候都可能被回收，主要用来跟踪对象被垃圾回收的过程","link":"/2020/11/04/java-garbage-collection/"},{"title":"Java 对象创建过程","text":"Java 对象创建过程如图： Java 字节码文件结构Java Class 文件的结构 ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 } Class 文件字节码结构组织示意图 Class 文件详细结构如下： 魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。 Class 文件版本 ：Class 文件的版本号，保证编译正常执行。 常量池 ：常量池主要存放两大常量：字面量和符号引用。 访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。 当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。 接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。 字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。 方法表集合 ：类中的方法。 属性表集合 ： 在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。 Java对象创建过程1. 类加载检查当 JVM 遇到一条 new 指令时，会检查这条指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经 加载-连接-初始化，如果没有则必须完成类加载过程。类加载参考 Post not found: java-class-load Java类加载 2. 分配内存当类加载检查通过后需要给新生对象分配内存，对象所需的内存在类加载完成后便可确定大小分配内存方式有：指针碰撞和空闲列表 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的 虚拟机创建对象的过程是线程安全的虚拟机采用两种方式保证线程安全 CAS+失败重试：假设没有冲突去分配内存，因为冲突失败就重试，使用 CAS 保证操作的原子性 TLAB：为线程预先分配一块内存，JVM 给对象分配内存时优先在 TLAB 分配，TLAB 剩余空闲内存不足时，使用上面的 CAS+失败重试 分配 3. 初始化零值内存分配完成后，虚拟机需要将分配的内存空间都初始化成零值，保证对象的字段不赋初始值就能直接使用，程序能访问到这些字段类型所对应的零值 4. 设置对象头虚拟机需要为对象设置对象头对象头包含：对象所属的类、类元信息的引用、对象的哈希码、GC分代年龄等另外对象头中根据虚拟机的运行状态会有：是否启用偏向锁等 5. 执行 init 方法上面的步骤都完成后，虚拟机还会执行对象的 &lt;init&gt; 方法，按照程序员的意愿进行初始化","link":"/2020/11/04/java-object-create/"},{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q. 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true输入 [1 -&gt; 2 -&gt; 1], 输出true输入 [1 -&gt; 2], 输出false输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q. 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q. 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"},{"title":"学习笔记 2020-10-30","text":"今天回顾了一下集合类和 GC Root 有两处需要学习的知识点：HashMap 的红黑树转换方法，ConcurrentHashMap.helpTransfer() 的原理 算法题是来自于力扣网的 123. 买卖股票的最佳时机 III 难度：困难 集合类HashMap DEFAULT_INITIAL_CAPACITY ( 1 &lt;&lt; 4 ) : 默认初始化容量 16 MAXIMUM_CAPACITY ( 1 &lt;&lt; 30 ) : 最大容量 1 &lt;&lt; 30 DEFAULT_LOAD_FACTOR : 默认负载因子 0.75 TREEIFY_THRESHOLD : 链表转红黑树阈值 8 UNTREEIFY_THRESHOLD : 红黑树转链表阈值 6 MIN_TREEIFY_CAPACITY : 链表转红黑树最小Node数组大小 64 红黑树树转链表会发生在一下两处 数组扩容，红黑树拆分后，节点数小于 UNTREEIFY_THRESHOLD 删除节点后，root, root.right, root.left, root.left.left 任何一个为 null HashMap 线程不安全的原因 JDK 1.7 HashMap 扩容的时候，链表的节点顺序会反转，因此多线程操作可能出现环，get 操作的时候会出现死循环，也有可能丢失数据 JDK 1.8 HashMap 扩容的时候，链表节点不反转，不会出现环，但是可能丢失数据 未明确的知识点？ HashMap 红黑树的转换原理 ConcurrentHashMap helpTransfer() 的原理 其它集合类 List : ArrayList , LinkedList , Vector Set : HashSet , LinkedHashSet , TreeSet Map: HashMap , LinkedHashMap , TreeMap , Hashtable 进程&amp;线程进程 是程序运行的基本单位，线程 是系统调度的基本单位进程 拥有独立的内存区域，线程 的内存区域存在 独享 和 共享 （栈、堆） new Thread() 创建了一个线程，线程进入 NEW 状态thread.start() 启动线程并使线程进入就绪状态 GC RootGC Root 是垃圾回收期标记存活对象的起点 GC Root 有哪些 Class 由系统类加载器加载的对象 Thread 激活状态的线程 Stack Local 栈中的对象 JNI Local JNI栈中的对象 JNI Global JNI中的全局对象 Monitor Used 正在被用于同步的各种锁对象 Held By JVM JVM自身持有的对象，比如系统类加载器等 算法题今天算法题来自力扣网 123. 买卖股票的最佳时机 III 难度：困难 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 思考 可以看到，对于第一次买卖： 要获取从第 0 天开始，到第 i 天内，能获取到的最大利润 需要记录前 i - 1 天最小的买入价 min 使用第 i 天的买入价 - min，得到第 i 天的利润 使用上一步的利润与第 i - 1 天的利润相比，选择较大的一个作为第 i 天的利润 对于第二次买卖： 有两种思路： 从第 n - 1 天开始计算第 n - 1 天到第 1天可以获得的最大利润 第二个思路还没看太明白，参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/10208","link":"/2020/10/30/note-2020-10-30/"},{"title":"学习笔记 2020-11-02","text":"今天看了下二叉树的遍历和堆，熟悉了两者的结构和代码实现堆可以引申到优先级队列和堆排序冒泡排序的优化算法鸡尾酒排序，通过反向遍历避免极端情况快速排序有可以双边循环和单边循环了解到计数排序和引申出来的桶排序综上明白了堆排序、冒泡排序（优化的鸡尾酒排序）、快速排序、计数排序和桶排序 今日算法题：力扣网 377. 组合总和 Ⅳ 队列、堆二叉树二叉树的深度优先遍历二叉树的深度优先遍历有两种常用方法 递归方法，最常用 使用栈保存节点以先序遍历为例： 从根节点开始遍历当存在左子节点时，将当前节点入栈，继续遍历左子节点，遍历完成后将父节点出栈遍历父节点的右子节点 广度优先遍历 与深度优先遍历不同，较多使用的是队列保存已遍历的节点 从根节点开始遍历从队头依次取出节点如果取出的节点有子节点，则将子节点加入到队尾 最大堆、最小堆 最小堆(小顶堆): 所有父节点都比其子节点小 最大堆(大顶堆): 所有父节点都比其子节点大 构建堆构建堆的方式是下沉以最小堆为例 从最后一个非叶子节点开始，依次遍历非叶子节点 找到左右子节点较小的一个 父节点与上一步找到的最小的节点比较，如果比子节点大，则交换两个节点位置，否则回到第一步 将用于交换的子节点作为新的父节点，从第2步重新开始比较 构建最大堆与最小堆的区别第2步找到较大的一个第3步如果比子节点小则交换位置 插入/删除节点 插入节点：新插入的节点作为最后一个节点，做上浮操作 删除节点：从堆顶删除节点，将最后一个节点放到堆顶，做下沉操作 上浮/下沉代码示例 上浮操作 1234567891011private void upAdjust(int[] array) { int childIdx = array.length - 1; int parentIdx = (childIdx - 1) / 2; int temp = array[childIdx]; while (childIdx &gt; 0 &amp;&amp; temp &lt; array[parentIdx]) { array[childIdx] = array[parentIdx]; childIdx = parentIdx; parentIdx = (childIdx - 1) / 2; } array[childIdx] = temp;} 下沉操作 123456789101112131415161718192021private void downAdjust(int[] array, int parentIdx) { int len = array.length; int temp = array[parentIdx]; int childIdx = parentIdx * 2 + 1; while (childIdx &lt; len) { // 如果有右孩子，并且右孩子比左孩子小，则与右孩子交换 if (childIdx + 1 &lt; len &amp;&amp; array[childIdx + 1] &lt; array[childIdx]) { childIdx++; } if (temp &lt;= array[childIdx]) { break; } // 将左/右孩子上移 array[parentIdx] = array[childIdx]; // 孩子节点作为新的父节点 parentIdx = childIdx; // 下一个孩子节点 childIdx = parentIdx * 2 + 1; } array[parentIdx] = temp;} 优先级队列优先级队列的一种实现方式是使用最大堆 入队：新插入的节点作为最大堆的最后一个节点，然后上浮 出队：从最大堆顶删除节点 排序算法堆排序堆排序的实现方式 从排序数据构建堆，升序-&gt;最大堆，降序-&gt;最小堆 将堆顶元素与最后一个节点交换位置 新的堆顶元素下沉，下沉的界限是未排序的部分 鸡尾酒排序鸡尾酒排序与冒泡排序类似遍历的方式改为：从左往右遍历，再从右往左遍历如果某一个遍历未发生交换，则认为数据已经有序 快速排序 双边循环法 选择一个基准元素left和right两个索引分别向中间移动，和交换元素，left索引需要优先于right索引移动，否则影响下一步的交换当两个索引重合时，索引指向的元素和基准元素交换位置以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 单边循环法 以最左边元素为基准元素指定mask指针指向基准元素往右遍历，如果有比基准元素小的元素时，mask指针向右移动一位，与遍历的元素交换位置当遍历完后，mask指针指向的元素与基准元素交换以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 快速排序的非递归实现 将每一步产生的两段的start、end索引放入到一个栈中弹出元素遍历，将新的两段重新入栈，直至栈清空 计数排序排序方式 获取数组元素的最小和最大值以最小和最大值的距离创建一个countArray数组遍历数组，将数组元素对应countArray数组位置的值+1遍历统计数组，输出结果 缺点只能排序整数数组，如果数组含有小数则无法排序最小值和最大值差距过大是造成空间浪费 桶排序排序方式 获取数组元素的最小和最大值，得到最大值与最小值的间距d以最小和最大值的距离创建一个List的数组遍历数组，(array[i] - min) / d * (数组大小 - 1)将元素放入上一步找到的桶List中每个List内部进行排序遍历数组，输出每个List的值 缺点最小值和最大值差距过大是造成空间浪费 算法题LeetCode 377. 组合总和 Ⅳ今天算法题来自于力扣网 377. 组合总和 Ⅳ 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 123456789101112131415示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 基本思路 动态规划是每次第i+n位置加上第i位置的排列数递归法是计算每个target-n的排列数之和 代码实现 动态规划 12345678910111213141516class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; Arrays.sort(nums); dp[0] = 1; for (int i = 0; i &lt; target; i++) { for (int n : nums) { if (i + n &lt;= target) { // dp数组位置+n，既新的位置多了dp[i]种排列 dp[i + n] += dp[i]; } } } return dp[target]; }} 递归 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { if (target == 0) { return 1; } int count = 0; for (int n : nums) { if (target &gt;= n) { // target的排列数 = 每个target-n的排列数之和 count += combinationSum4(nums, target - n); } } return count; }}","link":"/2020/11/02/note-2020-11-02/"},{"title":"学习笔记 2020-11-04","text":"今天学习了JVM的内存结构和GC策略；代码实现了链表环的检测、获取环长度和入口今日算法题：力扣网 139. 单词拆分 JVMJVM内存结构 虚拟机栈 栈由栈帧组成，一个栈帧包含：局部变量表、操作数栈、动态链接、方法出口，局部变量表所需内存大小在编译器确定方法调用的方式：每一次方法调用都会有一个对应的栈帧入栈，方法调用结束后出栈现在的Java虚拟机的栈一般允许动态扩展，即栈空间不足时动态扩展栈空间大小 当栈的深度达到最大深度时，抛出 StackOverflowError当栈空间内存无法扩展时，抛出 OutOfMemoryError 本地方法栈 与虚拟机栈类似区别是虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务在HotSpot虚拟机中，虚拟机栈和本地方法栈合二为一。 程序计数器 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码流程控制，如：顺序执行、循环、选择、异常处理等；程序计数器可以记录线程执行的位置，当线程上下文切换时可以知道上一次线程运行到哪儿了 程序计数器的生命周期和线程一致，是唯一不会发生 OutOfMemoryError 的内存区域 堆 线程共享的区域，用于存放存活对象的实例堆的垃圾回收一般采用分代收集算法，因此堆可以分为：新生代和老年代新生代可以细分为：Eden, From Survior, To Survior, （Eden, S0, S1） 方法区 《Java虚拟机规范》定义了方法区这个概念和它的作用，并没有规定怎么去实现永久代是 HotSpot 虚拟机对虚拟机规范中方法区的实现，方法区存放：Java类信息、常量池、静态变量、JIT编译的代码数据 从JDK 1.7 开始，字符串常量池 移到堆中从JDK 1.8 开始，字符串常量池 和 静态变量 移到了堆中，方法区被彻底移除，使用元空间替代，元空间申请在直接内存中 JDK 1.7 及之前，可以使用 -XX:PermSize=N 和 -XX:MaxPermSize=N 配置方法区大小，超出内存将抛出 OutOfMemoryError: PermGen 异常JDK 1.8 及之后，使用 -XX:MetaspaceSize=N 和 -XX:MaxMetaspaceSize=N 配置元空间大小，上限默认为 unlimited，只受系统内存限制 直接内存 直接内存不是JVM运行时数据区的一部分直接内存只受系统内存空间的限制Java NIO中，通过 Native 方法直接分配堆外内存，然后通过存储在堆上的 DirectByteBuffer 作为这块内存的引用进行操作，减少数据在 Java 堆 和 Native 堆 之间的来回复制 运行时常量池方法区中存放着class文件的信息和运行时常量池 class文件的信息包含类型西和静态常量池，静态常量池结构如下图 当类加载到内存中时：加载阶段：JVM将class类的静态常量池的内容放入运行时常量池解析阶段：JVM将常量池中的符号引用替换为直接引用 在JDK 1.7，字符串常量池移到了堆中在JDK 1.8，静态变量移到了堆中，剩余的放到位于直接内存的 MetaSpace 中 字符串常量池存放的是字符串对象的引用，字符串对象仍然在堆中 对象创建对象创建，参考 Java 对象创建过程 GC 垃圾收集垃圾回收算法：复制、标记-清除、标记-整理Minor GC: 新生代GCMajor GC：老年代GCFull GC：清理整个堆，包括年轻代、老年代和方法区垃圾收集，参考 JVM 垃圾收集 算法链表中环的问题有一个链表如图 Q1. 判断链表中是否存在环 方法1：一个指针从头开始遍历链表，每遍历一个节点，就从头检查一下这个节点是否被遍历过时间复杂度：O(n^2), 空间复杂度：O(1) 方法2：从头遍历链表，将已遍历的节点放入一个Hash表中，没遍历一个新节点判断一下这个节点是否在Hash表中时间复杂度：O(n), 空间复杂度：O(n) 方法3：有两个快慢指针分别从头遍历链表，快指针每次移动2步，慢指针每次移动1步如果链表中有环，那么快指针移动会在经过 n 个环后追上慢指针 (n &gt;= 1) 方法3的做法如图 可以看到两个指针从起点 S 出发，最终相遇于环内 代码实现 123456789101112131415public boolean isCycle(Node head) { Node fast = head; Node slow = head; while (fast != null &amp;&amp; fast.next != null) { // 快指针每次移动2步 fast = fast.next.next; // 慢指针每次移动1步 slow = slow.next; // 快慢指针相遇 if (fast == slow) { return true; } } return false;} Q2：求链表环的长度依据上一个问题的方法3，快慢指针的速度相差1。因此当两个指针到达相遇点后，让两个指针记录移动当两个指针再次相遇时，慢指针走过的距离既是环的长度 Q3: 找到环的入环节点继续参考这张图当两个指针相遇时两个指针走过的距离： 快指针 = D + S1 + n * (S1 + S2), (n &gt;= 1) 慢指针 = D + S1 由于快指针是慢指针的速度的2倍因此： 2(D + S1) = D + S1 + n(S1 + S2), (n &gt;= 1)可以推出： D = (n-1)(S1 + S2) + S2, (n &gt;= 1) 因此可以把其中一个指针放到首次相遇点，另一个指针放到头节点位置，两个指针每次都各向前走1步，当两个指针再次相遇时，相遇的点就是入环节点 力扣网：139. 单词拆分Q: 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 思路看到这一题可以想到的是暴力求解，但是这种思路的时间复杂度和空间复杂度都很高这个问题其实也可以看成是，已知字符串 s 的前 n 个字符已经在给定的字典中，求剩下的字符是否在给定的字典中那么这个问题就会转化成动态规划的背包问题 实现 解法1：遍历字符串 s, 前i个字符是否在字符串中，既当前 j 个字符在字典中时第 (j, i) 个字符是否在字典中 1234567891011121314151617class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (int j = 0; j &lt; i; j++) { // 当前第j个字符在字典中，判断 (j, i) 是否在字典中 if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这种方式存在重复计算的问题，每次都需要将前 i-1 个字符计算一遍解法2对这个问题做了些优化 解法2：遍历字符串 s 时，通过遍历字典，判断字典是否是当前已遍历部分的末尾，和字典字符串的前一个字符的 dp 位置是否为 true 12345678910111213141516171819class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (String str : wordDict) { // i &gt;= str.length(): 避免多余的判断 // dp[i - str.length()]: 判断dp位置 i - str.length()，表示去除末尾字符串str后剩下的字符串是在字典中 // s.substring(i - str.length(), i): 判断str是否是已遍历字符串的末尾部分 if (i &gt;= str.length() &amp;&amp; dp[i - str.length()] &amp;&amp; str.equals(s.substring(i - str.length(), i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这个问题有个变形的题目 力扣网：140. 单词拆分 II输出所有的拆分情况比较简单的思路是从字符串首部取字典中存在的部分，然后递归遍历子串， 有两处可以优化的可以使用 139. 单词拆分 的思路判断子串是否在字典中，优化时间效率可以使用Hash表的方式记录每个子串是否在字典中 使用 139 问题的思路优化后所需时间大幅减少 这一题看题解有使用回溯的思想做的，需要研究下回溯怎么实现的TODO 使用回溯的思想求解 140. 单词拆分 II","link":"/2020/11/04/note-2020-11-04/"},{"title":"学习笔记 2020-11-09","text":"今天看了一些算法问题。下面给出一个常见的算法问题的思路和解决办法 寻找全排列的下一个数 大整数加法 寻找缺失的数：99个1-100范围内的不重复数，出现奇数次的1个/2个数 算法寻找全排列的下一个数问题给定一个数，找出这个数中数字全排列的下一个数，如：12345 -&gt; 1235412354 -&gt; 12435 思路如果一个数后面的数时顺序的，如：45，那么下一个数一定是最后的两个数倒序，既：54同理，如果后面的数时倒序的，就说明后面已经是最后一个排列，下一个全排列的数就需要网前一位看，如：354，下一个数应该要从 3 开始看 代码实现 123456789101112131415class Solution { public String nextSeq(String num) { for (int i = num.length() - 1; i &gt; 0; i--) { // 找到比前一个数字大的数字的位置 if (num.charAt(i) &gt; num.charAt(i-1)) { // 前一部分保持不变，后一部分反转，找到的数字放到最后面 return num.substring(0, i-1) + new StringBuffer(num.substring(i)).reverse().toString() + num.charAt(i-1); } } // 数字已经是倒序了 return num; }} 大整数加法思路 按位加 拆分成可以计算的数第一种方法使用数组存放大整数，从低位到高位按位加，代码省略方法2的实现 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution { public String bigNumberAdd(String n1, String n2) { int numLen = n1.length() &gt; n2.length() ? n1.length() : n2.length(); int len = numLen / 9 + 1; int[] arr1 = parseNum(n1, len); int[] arr2 = parseNum(n2, len); // 按数组为相加，如果 &gt; 999999999, 则往下一位+1 for (int i = 0; i &lt; len; i++) { arr1[i] = arr1[i] + arr2[i]; if (i &lt; (len - 1) &amp;&amp; arr1[i] &gt; 999999999) { arr1[i + 1] = arr1[i + 1] + 1; arr1[i] = Integer.valueOf(String.valueOf(arr1[i]).substring(1)); } } // 组装结果 StringBuilder res = new StringBuilder(); boolean fill = false; for (int i = len - 1; i &gt;= 0; i--) { if (arr1[i] &gt; 0 || fill) { // 判断是否需要填充0 if (fill) { res.append(fillZero(arr1[i])); } else { res.append(arr1[i]); fill = true; } } } return res.toString(); } /** * 填充0 * @param n * @return */ private String fillZero(int n) { String ns = String.valueOf(n); StringBuilder str = new StringBuilder(n); for (int i = 0; i &lt; 9 - ns.length(); i++) { str.append('0'); } str.append(ns); return str.toString(); } /** * 字符串转成int数组 * @param num * @param len * @return */ private int[] parseNum(String num, int len) { int[] arr = new int[len]; int nLen = num.length() % 9 == 0 ? num.length() / 9 : num.length() / 9 + 1; int pos = nLen - 1; for (int i = 0; i &lt; nLen; i++) { // 12 345678912 345678900 int start = num.length() - (i + 1) * 9; int end = num.length() - i * 9; if (start &lt; 0) { start = 0; } arr[i] = Integer.valueOf(num.substring(start, end)); } return arr; }} 寻找缺失的数问题问题 有99个不重复数，取值范围是1-100，要求找出缺失的那个数 有若干个正整数，其中n个数出现了偶数次，另有1个整数出现了奇数次，要求找出这个出现奇数次的数 有若干个正整数，其中n个数出现了偶数次，另有2个整数出现了奇数次，要求找出这2个出现奇数次的数 思路 问题1：计算1-100内所有数的和，减去99个不重复数的和，结果就是缺失的那个数 问题2:由于两个相同数异或后为0，所以将所有的数异或后，结果就是出现奇数次的那个数 问题3:按照问题2的方法得到一个数，找到根据出现1的位异或，可以找到两个数 代码实现 1234567891011121314151617181920212223242526class Solution { public void twoNum(int[] nums) { // 异或 int n = 0; for (int i = 0; i &lt; nums.length; i++) { n ^= nums[i]; } // 找到两个数的不同位 int bit = 1; while ((bit &amp; n) == 0) { bit &lt;&lt;= 1; } int r1 = 0; int r2 = 0; for (int i = 0; i &lt; nums.length; i++) { // 依据不同位分组所有的数并异或，得到两个出线奇数次的数 if ((nums[i] &amp; bit) == 0) { r1 ^= nums[i]; } else { r2 ^= nums[i]; } } System.out.println(r1); System.out.println(r2); }}","link":"/2020/11/09/note-2020-11-09/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"垃圾收集","slug":"垃圾收集","link":"/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java线程","slug":"Java线程","link":"/tags/Java%E7%BA%BF%E7%A8%8B/"},{"name":"Java算法","slug":"Java算法","link":"/tags/Java%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}