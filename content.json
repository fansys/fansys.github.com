{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q. 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true输入 [1 -&gt; 2 -&gt; 1], 输出true输入 [1 -&gt; 2], 输出false输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q. 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q. 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"},{"title":"学习笔记 2020-11-02","text":"今天看了下二叉树的遍历和堆，熟悉了两者的结构和代码实现堆可以引申到优先级队列和堆排序冒泡排序的优化算法鸡尾酒排序，通过反向遍历避免极端情况快速排序有可以双边循环和单边循环了解到计数排序和引申出来的桶排序综上明白了堆排序、冒泡排序（优化的鸡尾酒排序）、快速排序、计数排序和桶排序 今日算法题：力扣网 377. 组合总和 Ⅳ 队列、堆二叉树二叉树的深度优先遍历二叉树的深度优先遍历有两种常用方法 递归方法，最常用 使用栈保存节点以先序遍历为例： 从根节点开始遍历当存在左子节点时，将当前节点入栈，继续遍历左子节点，遍历完成后将父节点出栈遍历父节点的右子节点 广度优先遍历 与深度优先遍历不同，较多使用的是队列保存已遍历的节点 从根节点开始遍历从队头依次取出节点如果取出的节点有子节点，则将子节点加入到队尾 最大堆、最小堆 最小堆(小顶堆): 所有父节点都比其子节点小 最大堆(大顶堆): 所有父节点都比其子节点大 构建堆构建堆的方式是下沉以最小堆为例 从最后一个非叶子节点开始，依次遍历非叶子节点 找到左右子节点较小的一个 父节点与上一步找到的最小的节点比较，如果比子节点大，则交换两个节点位置，否则回到第一步 将用于交换的子节点作为新的父节点，从第2步重新开始比较 构建最大堆与最小堆的区别第2步找到较大的一个第3步如果比子节点小则交换位置 插入/删除节点 插入节点：新插入的节点作为最后一个节点，做上浮操作 删除节点：从堆顶删除节点，将最后一个节点放到堆顶，做下沉操作 上浮/下沉代码示例 上浮操作 1234567891011private void upAdjust(int[] array) { int childIdx = array.length - 1; int parentIdx = (childIdx - 1) / 2; int temp = array[childIdx]; while (childIdx &gt; 0 &amp;&amp; temp &lt; array[parentIdx]) { array[childIdx] = array[parentIdx]; childIdx = parentIdx; parentIdx = (childIdx - 1) / 2; } array[childIdx] = temp;} 下沉操作 123456789101112131415161718192021private void downAdjust(int[] array, int parentIdx) { int len = array.length; int temp = array[parentIdx]; int childIdx = parentIdx * 2 + 1; while (childIdx &lt; len) { // 如果有右孩子，并且右孩子比左孩子小，则与右孩子交换 if (childIdx + 1 &lt; len &amp;&amp; array[childIdx + 1] &lt; array[childIdx]) { childIdx++; } if (temp &lt;= array[childIdx]) { break; } // 将左/右孩子上移 array[parentIdx] = array[childIdx]; // 孩子节点作为新的父节点 parentIdx = childIdx; // 下一个孩子节点 childIdx = parentIdx * 2 + 1; } array[parentIdx] = temp;} 优先级队列优先级队列的一种实现方式是使用最大堆 入队：新插入的节点作为最大堆的最后一个节点，然后上浮 出队：从最大堆顶删除节点 排序算法堆排序堆排序的实现方式 从排序数据构建堆，升序-&gt;最大堆，降序-&gt;最小堆 将堆顶元素与最后一个节点交换位置 新的堆顶元素下沉，下沉的界限是未排序的部分 鸡尾酒排序鸡尾酒排序与冒泡排序类似遍历的方式改为：从左往右遍历，再从右往左遍历如果某一个遍历未发生交换，则认为数据已经有序 快速排序 双边循环法 选择一个基准元素left和right两个索引分别向中间移动，和交换元素，left索引需要优先于right索引移动，否则影响下一步的交换当两个索引重合时，索引指向的元素和基准元素交换位置以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 单边循环法 以最左边元素为基准元素指定mask指针指向基准元素往右遍历，如果有比基准元素小的元素时，mask指针向右移动一位，与遍历的元素交换位置当遍历完后，mask指针指向的元素与基准元素交换以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 快速排序的非递归实现 将每一步产生的两段的start、end索引放入到一个栈中弹出元素遍历，将新的两段重新入栈，直至栈清空 计数排序排序方式 获取数组元素的最小和最大值以最小和最大值的距离创建一个countArray数组遍历数组，将数组元素对应countArray数组位置的值+1遍历统计数组，输出结果 缺点只能排序整数数组，如果数组含有小数则无法排序最小值和最大值差距过大是造成空间浪费 桶排序排序方式 获取数组元素的最小和最大值，得到最大值与最小值的间距d以最小和最大值的距离创建一个List的数组遍历数组，(array[i] - min) / d * (数组大小 - 1)将元素放入上一步找到的桶List中每个List内部进行排序遍历数组，输出每个List的值 缺点最小值和最大值差距过大是造成空间浪费 算法题LeetCode 377. 组合总和 Ⅳ今天算法题来自于力扣网 377. 组合总和 Ⅳ 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 123456789101112131415示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 基本思路 动态规划是每次第i+n位置加上第i位置的排列数递归法是计算每个target-n的排列数之和 代码实现 动态规划 12345678910111213141516class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; Arrays.sort(nums); dp[0] = 1; for (int i = 0; i &lt; target; i++) { for (int n : nums) { if (i + n &lt;= target) { // dp数组位置+n，既新的位置多了dp[i]种排列 dp[i + n] += dp[i]; } } } return dp[target]; }} 递归 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { if (target == 0) { return 1; } int count = 0; for (int n : nums) { if (target &gt;= n) { // target的排列数 = 每个target-n的排列数之和 count += combinationSum4(nums, target - n); } } return count; }}","link":"/2020/11/02/note-2020-11-02/"},{"title":"学习笔记 2020-10-30","text":"今天回顾了一下集合类和 GC Root 有两处需要学习的知识点：HashMap 的红黑树转换方法，ConcurrentHashMap.helpTransfer() 的原理 算法题是来自于力扣网的 123. 买卖股票的最佳时机 III 难度：困难 集合类HashMap DEFAULT_INITIAL_CAPACITY ( 1 &lt;&lt; 4 ) : 默认初始化容量 16 MAXIMUM_CAPACITY ( 1 &lt;&lt; 30 ) : 最大容量 1 &lt;&lt; 30 DEFAULT_LOAD_FACTOR : 默认负载因子 0.75 TREEIFY_THRESHOLD : 链表转红黑树阈值 8 UNTREEIFY_THRESHOLD : 红黑树转链表阈值 6 MIN_TREEIFY_CAPACITY : 链表转红黑树最小Node数组大小 64 红黑树树转链表会发生在一下两处 数组扩容，红黑树拆分后，节点数小于 UNTREEIFY_THRESHOLD 删除节点后，root, root.right, root.left, root.left.left 任何一个为 null HashMap 线程不安全的原因 JDK 1.7 HashMap 扩容的时候，链表的节点顺序会反转，因此多线程操作可能出现环，get 操作的时候会出现死循环，也有可能丢失数据 JDK 1.8 HashMap 扩容的时候，链表节点不反转，不会出现环，但是可能丢失数据 未明确的知识点？ HashMap 红黑树的转换原理 ConcurrentHashMap helpTransfer() 的原理 其它集合类 List : ArrayList , LinkedList , Vector Set : HashSet , LinkedHashSet , TreeSet Map: HashMap , LinkedHashMap , TreeMap , Hashtable 进程&amp;线程进程 是程序运行的基本单位，线程 是系统调度的基本单位进程 拥有独立的内存区域，线程 的内存区域存在 独享 和 共享 （栈、堆） new Thread() 创建了一个线程，线程进入 NEW 状态thread.start() 启动线程并使线程进入就绪状态 GC RootGC Root 是垃圾回收期标记存活对象的起点 GC Root 有哪些 Class 由系统类加载器加载的对象 Thread 激活状态的线程 Stack Local 栈中的对象 JNI Local JNI栈中的对象 JNI Global JNI中的全局对象 Monitor Used 正在被用于同步的各种锁对象 Held By JVM JVM自身持有的对象，比如系统类加载器等 算法题今天算法题来自力扣网 123. 买卖股票的最佳时机 III 难度：困难 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 思考 可以看到，对于第一次买卖： 要获取从第 0 天开始，到第 i 天内，能获取到的最大利润 需要记录前 i - 1 天最小的买入价 min 使用第 i 天的买入价 - min，得到第 i 天的利润 使用上一步的利润与第 i - 1 天的利润相比，选择较大的一个作为第 i 天的利润 对于第二次买卖： 有两种思路： 从第 n - 1 天开始计算第 n - 1 天到第 1天可以获得的最大利润 第二个思路还没看太明白，参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/10208","link":"/2020/10/30/note-2020-10-30/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java算法","slug":"Java算法","link":"/tags/Java%E7%AE%97%E6%B3%95/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java线程","slug":"Java线程","link":"/tags/Java%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}