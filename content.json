{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q: 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true 输入 [1 -&gt; 2 -&gt; 1], 输出true 输入 [1 -&gt; 2], 输出false 输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q: 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q: 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}