{"pages":[{"title":"关于我","text":"这是关于我","link":"/about/index.html"}],"posts":[{"title":"JVM 垃圾收集","text":"本文主要介绍 Java 堆的垃圾收集策略和一些常见的垃圾收集器 新生代垃圾收集新生代的垃圾回收一般采用复制算法，回收的过程如下： 将 Eden 和 S0 中存活的对象复制到 S1 中，对象年龄+1，当对象年龄到达阈值（默认: 15）时，对象将晋升到老年代 清空 Eden 内存区域，交换 S0 和 S1 区域 如果 S1 区域存放不下则使用分配担保机制直接进入老年代 对象晋升老年代的阈值可以通过 -XX:MaxTenuringThreshold 设置 老年代垃圾收集Minor GC 和 Full GC 新生代GC (Minor GC): 新生代发生的 GC，Minor GC 非常频繁，速度也比较快 老年代GC (Major GC / Full GC): 老年代的 GC，通常伴有至少一次 Minor GC （并非绝对），回收时间是 Minor GC 的10倍以上 垃圾回收算法 复制算法：将内存分为大小相同的两块，每次将存活的对象复制到另一块，再把使用的空间一次清理掉 标记-清除：先标记需要回收的对象，标记完成后一次清理掉需要回收的对象，会产生内存碎片 标记-整理：先标记需要回收的对象，再将存活对象向一端移动，完成后清除端边界以外的内存 垃圾收集器常见的垃圾收集器有： Serial, ParNew, Parallel Scavenge,CMS、G1 Serial使用单线程收集，新生代使用复制算法，老年代使用标记整理 ParNew使用多线程收集，其余和 Serial 一样，新生代使用复制算法，老年代使用标记整理 Parallel Scavenge关注吞吐量，可以通过一些参数指定需要优化的目标，垃圾收集器能自动优化-XX:MaxGCPauseMillis 最大暂停时间, 0以上/毫秒-XX:GCTimeRatio GC时间占总时间的比例, 0-100-XX:+UseAdptiveSizePolicy 根据性能监控信息，动态调整参数 Serial OldSerial 收集器的老年代版本，可作为 CMS 的后备收集器 Parallel OldParallel Scavenge 收集器的老年代版本，可作为 CMS 的后备收集器 CMSCMS（Concurrent Mark Sweep）是以获得最短停顿时间为目标的收集器优点：并发收集，停顿时间短缺点：会产生内存碎片，因此需要使用 Serial Old 或 Parallel Old 作为后备收集器 CMS 是一种用 标记-清除 算法的实现，分为四个步骤 初始标记：暂停所有线程，并记录与 GC Roots 直接相连的对象，很快并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象，同时记录用户线程更新的引用域重新标记：暂停用户线程，修正并发标记期间因为用户线程运行而导致标记产生变动的那一部分对象的标记记录，时间比初始标记长，远远比并发标记短并发清除：同时开启用户线程，对标记区域进行清除 G1Heap 被划分为一个个大小相等的不连续的内存区域(Region)每个 Region 都有一个分代角色: Eden, Survior, Old（old还有一种细分 humongous，用来存放大小超过 region 50%以上的巨型对象）每个 Region 的角色可以变更每个角色的数量没有强制的限定，默认年轻代占5% G1优先去执行大量对象可被回收的 Region，使用暂停可预测决定一次回收多少 RegionG1从多个 Region 中复制存活对象到1个 Region，同时整理-清除内存 TODO 待补充 如何判断对象可被回收？算法 引用计数给对象分配一个计数器，当被引用时计数器+1，使用完后计数器-1，当计数器为0时，对象不可能被引用 可达性分析可达性分析是从 GC Roots 往下搜索，当对象未被任一 GC Root 链引用到时，则证明对象不可用可被回收 GC Root可以作为 GC Roots 的对象 由 系统类加载器 (System Class Loader) 加载的对象 Thread - 活着的线程 Stack Local - Java 方法的local变量或参数 JNI Local - JNI 方法的local变量或参数 JNI Global - 全局 JNI 引用 Monitor Used - 用于同步的监控对象 Held by JVM - 由JVM GC 保留的对象 强引用、软引用、弱引用、虚引用 强引用：直接引用的对象 软引用：可有可无的对象，当内存不足时，会被回收 弱引用：可有可无的对象，生命周期比弱引用短，当发生GC是会被回收 虚引用：任何时候都可能被回收，主要用来跟踪对象被垃圾回收的过程","link":"/2020/11/04/java-garbage-collection/"},{"title":"Java 对象创建过程","text":"Java对象创建过程Java 对象创建过程如图： 1. 类加载检查当 JVM 遇到一条 new 指令时，会检查这条指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经 加载-连接-初始化，如果没有则必须完成类加载过程。类加载参考 Post not found: java-class-load Java类加载 2. 分配内存当类加载检查通过后需要给新生对象分配内存，对象所需的内存在类加载完成后便可确定大小分配内存方式有：指针碰撞和空间列表 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的 虚拟机创建对象的过程是线程安全的虚拟机采用两种方式保证线程安全 CAS+失败重试：假设没有冲突去分配内存，因为冲突失败就重试，使用 CAS 保证操作的原子性 TLAB：为线程预先分配一块内存，JVM 给对象分配内存时优先在 TLAB 分配，TLAB 剩余空闲内存不足时，使用上面的 CAS+失败重试 分配 3. 初始化零值内存分配完成后，虚拟机需要将分配的内存空间都初始化成零值，保证对象的字段不赋初始值就能直接使用，程序能访问到这些字段类型所对应的零值 4. 设置对象头虚拟机需要为对象设置对象头对象头包含：对象所属的类、类元信息的引用、对象的哈希码、GC分代年龄等另外对象头中根据虚拟机的运行状态会有：是否启用偏向锁等 5. 执行 init 方法上面的步骤都完成后，虚拟机还会执行对象的 &lt;init&gt; 方法，按照程序员的意愿进行初始化","link":"/2020/11/04/java-object-create/"},{"title":"学习笔记 2020-10-29","text":"今天回顾了一下前几天面试碰到的几个问题，对此做一些记录。主要问题是关于Java基础的 实现了一下力扣网 234.回文联表 实现了整数序列的 indexOf() 和 二叉树的右视图 Java基础学习1. ArrayList 扩容的机制查看了一下 Java 8 中 ArrayList 的源码，每次 add() 元素的时候会判断当前的 元素数量 +1 是否大于 Object 数组的大小，如果大于 Object 数组的大小，则会触发扩容操作，具体操作如下： 数组扩容的时候将原数组元素复制到新数组新数组的大小为原数组大小的1.5倍, newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)如果 newCapacity &gt; MAX_ARRAY_SIZE, 则会触发 hugeCapacity() 的校验，取 Integer.MAX_VALUE 和 MAX_ARRAY_SIZE 中的较大者MAX_ARRAY_SIZE 默认大小是 Integer.MAX_VALUE - 8 使用此大小是为了避免某些 VM 将 header words 放到数组中的问题 2. ArrayList 和 LinkedList 的区别ArrayList 底层结构是一个 Object 数组，适用于读多写少，新增 / 删除元素都可能出现数组元素的复制，如果超出数组大小则会出现扩容操作LinkedList 底层架构是一个双向链表，适用于读少写多，新增 / 删除元素很快，查找元素需要遍历链表 算法题Q. 判断一个链表是否为回文链表题目：力扣网 234.回文联表 输入 [1 -&gt; 2 -&gt; 2 -&gt; 1], 输入 true输入 [1 -&gt; 2 -&gt; 1], 输出true输入 [1 -&gt; 2], 输出false输入 [], 输出true 思路 使用快慢两个节点，找到链表的中间点 慢节点的 next 必为链表的后半部分 从慢节点的 next 节点开始反转链表 遍历反转后的链表，与原链表的每个节点对比，如果有不同的则不是回文链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 针对后半部分 ListNode cur = slow.next; ListNode pre = null; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } while(pre != null) { if (pre.val != head.val) { return false; } pre = pre.next; head = head.next; } return true; }} 收获 反转链表常用的两种方式 使用循环反转：需要定义两个辅助节点，cur（当前节点）和 pre （上一个节点），先临时保存 cur.next，将当前 cur.next 指向 pre，将 cur 作为新的 pre，将临时保存的 cur.next 作为 cur 使用递归方式 Q. 在无穷大的整数序列中实现 indexOf() 方法题目 有一个无穷大的整数序列：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,….., 99, 100, 101 根据输入的位置索引找到当前位置的数字 思考 此题需要先找到整数序列规律，可以看出，数值的位数是有规律的 1位数：9个，共9个数字 2位数：90个，10 - 99，共2*90个数字 3位数：900个，100-999，共3*900个数字 所以可以先找到 indexOf() 所在的是几位数 代码 12345678910111213141516171819202122232425262728293031class Solution { public int indexOf(int idx) { int width = 1; int count = 9; int start = 1; while (idx - count &gt; 0) { idx = idx - count; width += 1; count *= 10; start *= 10; } // 数值相对于起始位置的偏移 int pos = idx / width; // 数值中的位置 int nIdx = idx % width; // 需要查找的数值 int num = start + pos; // 正好是数值的最后一位 if (nIdx == 0) { num -= 1; return num % 10; } while(nIdx &gt; 0) { // 依次获取从最高位到低位 num %= width; width /= 10; nIdx--; } return num; }} 收获 本题找到的规律就可很快的解答，需要注意边界范围 Q. 获取一个二叉树的右视图题目 有一个二叉树，需要获取它的右视图 思考 二叉树右视图可能包含了左子树上的节点，因此不能简单的遍历有节点 可以使用广度优先遍历的方案，遍历每一层的最后侧节点 为了节省空间，可以使用队列或者链表的方式存放每一层的节点 伪代码 123456789101112131415161718192021222324TreeNode root;Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();List&lt;Node&gt; result = new ArrayList&lt;&gt;();// 先把根节点放进去queue.offer(root);// 队列不为空while (! queue.isEmpty()) { int size = queue.size(); Node last = null; // 只遍历当前队列已存在的部分，新增的不遍历 for (int i = 0; i &lt; size; i++) { // 从队头获取节点 last = queue.pool(); // 依次将左右不为空的节点加入队列 if (last.left != null) { queue.add(last.left); } if (last.right != null) { queue.add(last.right); } // 最后一个节点为当前这一层的最右节点 result.add(last); }} 收获 关于这题基本思路用广度优先遍历，需要思考的问题是在遍历的过程中怎么尽可能少的创建对象 最开始的思路就是直接创建 List 保存当前层的节点，但是此种方式可能会创建很多个 List 使用队列的方式是否避免了创建不必要的对象？ 最后今天想到要把看到的东西记录下来就创建了这个博客，同时也发现了 Gitee 已经支持工作流，后续可以将一些自动化构建的任务迁移到 Gitee 了~","link":"/2020/10/29/note-2020-10-29/"},{"title":"学习笔记 2020-10-30","text":"今天回顾了一下集合类和 GC Root 有两处需要学习的知识点：HashMap 的红黑树转换方法，ConcurrentHashMap.helpTransfer() 的原理 算法题是来自于力扣网的 123. 买卖股票的最佳时机 III 难度：困难 集合类HashMap DEFAULT_INITIAL_CAPACITY ( 1 &lt;&lt; 4 ) : 默认初始化容量 16 MAXIMUM_CAPACITY ( 1 &lt;&lt; 30 ) : 最大容量 1 &lt;&lt; 30 DEFAULT_LOAD_FACTOR : 默认负载因子 0.75 TREEIFY_THRESHOLD : 链表转红黑树阈值 8 UNTREEIFY_THRESHOLD : 红黑树转链表阈值 6 MIN_TREEIFY_CAPACITY : 链表转红黑树最小Node数组大小 64 红黑树树转链表会发生在一下两处 数组扩容，红黑树拆分后，节点数小于 UNTREEIFY_THRESHOLD 删除节点后，root, root.right, root.left, root.left.left 任何一个为 null HashMap 线程不安全的原因 JDK 1.7 HashMap 扩容的时候，链表的节点顺序会反转，因此多线程操作可能出现环，get 操作的时候会出现死循环，也有可能丢失数据 JDK 1.8 HashMap 扩容的时候，链表节点不反转，不会出现环，但是可能丢失数据 未明确的知识点？ HashMap 红黑树的转换原理 ConcurrentHashMap helpTransfer() 的原理 其它集合类 List : ArrayList , LinkedList , Vector Set : HashSet , LinkedHashSet , TreeSet Map: HashMap , LinkedHashMap , TreeMap , Hashtable 进程&amp;线程进程 是程序运行的基本单位，线程 是系统调度的基本单位进程 拥有独立的内存区域，线程 的内存区域存在 独享 和 共享 （栈、堆） new Thread() 创建了一个线程，线程进入 NEW 状态thread.start() 启动线程并使线程进入就绪状态 GC RootGC Root 是垃圾回收期标记存活对象的起点 GC Root 有哪些 Class 由系统类加载器加载的对象 Thread 激活状态的线程 Stack Local 栈中的对象 JNI Local JNI栈中的对象 JNI Global JNI中的全局对象 Monitor Used 正在被用于同步的各种锁对象 Held By JVM JVM自身持有的对象，比如系统类加载器等 算法题今天算法题来自力扣网 123. 买卖股票的最佳时机 III 难度：困难 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 思考 可以看到，对于第一次买卖： 要获取从第 0 天开始，到第 i 天内，能获取到的最大利润 需要记录前 i - 1 天最小的买入价 min 使用第 i 天的买入价 - min，得到第 i 天的利润 使用上一步的利润与第 i - 1 天的利润相比，选择较大的一个作为第 i 天的利润 对于第二次买卖： 有两种思路： 从第 n - 1 天开始计算第 n - 1 天到第 1天可以获得的最大利润 第二个思路还没看太明白，参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/10208","link":"/2020/10/30/note-2020-10-30/"},{"title":"学习笔记 2020-11-04","text":"今天学习了JVM的内存结构和GC策略；代码实现了链表环的检测、获取环长度和入口今日算法题：力扣网 139. 单词拆分 JVMJVM内存结构 虚拟机栈 栈由栈帧组成，一个栈帧包含：局部变量表、操作数栈、动态链接、方法出口，局部变量表所需内存大小在编译器确定方法调用的方式：每一次方法调用都会有一个对应的栈帧入栈，方法调用结束后出栈现在的Java虚拟机的栈一般允许动态扩展，即栈空间不足时动态扩展栈空间大小 当栈的深度达到最大深度时，抛出 StackOverflowError当栈空间内存无法扩展时，抛出 OutOfMemoryError 本地方法栈 与虚拟机栈类似区别是虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务在HotSpot虚拟机中，虚拟机栈和本地方法栈合二为一。 程序计数器 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码流程控制，如：顺序执行、循环、选择、异常处理等；程序计数器可以记录线程执行的位置，当线程上下文切换时可以知道上一次线程运行到哪儿了 程序计数器的生命周期和线程一致，是唯一不会发生 OutOfMemoryError 的内存区域 堆 线程共享的区域，用于存放存活对象的实例堆的垃圾回收一般采用分代收集算法，因此堆可以分为：新生代和老年代新生代可以细分为：Eden, From Survior, To Survior, （Eden, S0, S1） 方法区 《Java虚拟机规范》定义了方法区这个概念和它的作用，并没有规定怎么去实现永久代是 HotSpot 虚拟机对虚拟机规范中方法区的实现，方法区存放：Java类信息、常量池、静态变量、JIT编译的代码数据 从JDK 1.7 开始，字符串常量池 移到堆中从JDK 1.8 开始，字符串常量池 和 静态变量 移到了堆中，方法区被彻底移除，使用元空间替代，元空间申请在直接内存中 JDK 1.7 及之前，可以使用 -XX:PermSize=N 和 -XX:MaxPermSize=N 配置方法区大小，超出内存将抛出 OutOfMemoryError: PermGen 异常JDK 1.8 及之后，使用 -XX:MetaspaceSize=N 和 -XX:MaxMetaspaceSize=N 配置元空间大小，上限默认为 unlimited，只受系统内存限制 直接内存 直接内存不是JVM运行时数据区的一部分直接内存只受系统内存空间的限制Java NIO中，通过 Native 方法直接分配堆外内存，然后通过存储在堆上的 DirectByteBuffer 作为这块内存的引用进行操作，减少数据在 Java 堆 和 Native 堆 之间的来回复制 运行时常量池方法区中存放着class文件的信息和运行时常量池 class文件的信息包含类型西和静态常量池，静态常量池结构如下图 当类加载到内存中时：加载阶段：JVM将class类的静态常量池的内容放入运行时常量池解析阶段：JVM将常量池中的符号引用替换为直接引用 在JDK 1.7，字符串常量池移到了堆中在JDK 1.8，静态变量移到了堆中，剩余的放到位于直接内存的 MetaSpace 中 字符串常量池存放的是字符串对象的引用，字符串对象仍然在堆中 对象创建对象创建，参考 Java 对象创建过程 GC 垃圾收集垃圾回收算法：复制、标记-清除、标记-整理Minor GC: 新生代GCMajor GC：老年代GCFull GC：清理整个堆，包括年轻代、老年代和方法区垃圾收集，参考 JVM 垃圾收集 算法链表中环的问题有一个链表如图 Q1. 判断链表中是否存在环 方法1：一个指针从头开始遍历链表，每遍历一个节点，就从头检查一下这个节点是否被遍历过时间复杂度：O(n^2), 空间复杂度：O(1) 方法2：从头遍历链表，将已遍历的节点放入一个Hash表中，没遍历一个新节点判断一下这个节点是否在Hash表中时间复杂度：O(n), 空间复杂度：O(n) 方法3：有两个快慢指针分别从头遍历链表，快指针每次移动2步，慢指针每次移动1步如果链表中有环，那么快指针移动会在经过 n 个环后追上慢指针 (n &gt;= 1) 方法3的做法如图 可以看到两个指针从起点 S 出发，最终相遇于环内 代码实现 123456789101112131415public boolean isCycle(Node head) { Node fast = head; Node slow = head; while (fast != null &amp;&amp; fast.next != null) { // 快指针每次移动2步 fast = fast.next.next; // 慢指针每次移动1步 slow = slow.next; // 快慢指针相遇 if (fast == slow) { return true; } } return false;} Q2：求链表环的长度依据上一个问题的方法3，快慢指针的速度相差1。因此当两个指针到达相遇点后，让两个指针记录移动当两个指针再次相遇时，慢指针走过的距离既是环的长度 Q3: 找到环的入环节点继续参考这张图当两个指针相遇时两个指针走过的距离： 快指针 = D + S1 + n * (S1 + S2), (n &gt;= 1) 慢指针 = D + S1 由于快指针是慢指针的速度的2倍因此： 2(D + S1) = D + S1 + n(S1 + S2), (n &gt;= 1)可以推出： D = (n-1)(S1 + S2) + S2, (n &gt;= 1) 因此可以把其中一个指针放到首次相遇点，另一个指针放到头节点位置，两个指针每次都各向前走1步，当两个指针再次相遇时，相遇的点就是入环节点 力扣网：139. 单词拆分Q: 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 思路看到这一题可以想到的是暴力求解，但是这种思路的时间复杂度和空间复杂度都很高这个问题其实也可以看成是，已知字符串 s 的前 n 个字符已经在给定的字典中，求剩下的字符是否在给定的字典中那么这个问题就会转化成动态规划的背包问题 实现 解法1：遍历字符串 s, 前i个字符是否在字符串中，既当前 j 个字符在字典中时第 (j, i) 个字符是否在字典中 1234567891011121314151617class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (int j = 0; j &lt; i; j++) { // 当前第j个字符在字典中，判断 (j, i) 是否在字典中 if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这种方式存在重复计算的问题，每次都需要将前 i-1 个字符计算一遍解法2对这个问题做了些优化 解法2：遍历字符串 s 时，通过遍历字典，判断字典是否是当前已遍历部分的末尾，和字典字符串的前一个字符的 dp 位置是否为 true 12345678910111213141516171819class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; // 背包问题 for (int i = 1; i &lt;= s.length(); i++) { for (String str : wordDict) { // i &gt;= str.length(): 避免多余的判断 // dp[i - str.length()]: 判断dp位置 i - str.length()，表示去除末尾字符串str后剩下的字符串是在字典中 // s.substring(i - str.length(), i): 判断str是否是已遍历字符串的末尾部分 if (i &gt;= str.length() &amp;&amp; dp[i - str.length()] &amp;&amp; str.equals(s.substring(i - str.length(), i))) { dp[i] = true; break; } } } return dp[s.length()]; }} 这个问题有个变形的题目 力扣网：140. 单词拆分 II输出所有的拆分情况比较简单的思路是从字符串首部取字典中存在的部分，然后递归遍历子串， 有两处可以优化的可以使用 139. 单词拆分 的思路判断子串是否在字典中，优化时间效率可以使用Hash表的方式记录每个子串是否在字典中 使用 139 问题的思路优化后所需时间大幅减少 这一题看题解有使用回溯的思想做的，需要研究下回溯怎么实现的TODO 使用回溯的思想求解 140. 单词拆分 II","link":"/2020/11/04/note-2020-11-04/"},{"title":"学习笔记 2020-11-02","text":"今天看了下二叉树的遍历和堆，熟悉了两者的结构和代码实现堆可以引申到优先级队列和堆排序冒泡排序的优化算法鸡尾酒排序，通过反向遍历避免极端情况快速排序有可以双边循环和单边循环了解到计数排序和引申出来的桶排序综上明白了堆排序、冒泡排序（优化的鸡尾酒排序）、快速排序、计数排序和桶排序 今日算法题：力扣网 377. 组合总和 Ⅳ 队列、堆二叉树二叉树的深度优先遍历二叉树的深度优先遍历有两种常用方法 递归方法，最常用 使用栈保存节点以先序遍历为例： 从根节点开始遍历当存在左子节点时，将当前节点入栈，继续遍历左子节点，遍历完成后将父节点出栈遍历父节点的右子节点 广度优先遍历 与深度优先遍历不同，较多使用的是队列保存已遍历的节点 从根节点开始遍历从队头依次取出节点如果取出的节点有子节点，则将子节点加入到队尾 最大堆、最小堆 最小堆(小顶堆): 所有父节点都比其子节点小 最大堆(大顶堆): 所有父节点都比其子节点大 构建堆构建堆的方式是下沉以最小堆为例 从最后一个非叶子节点开始，依次遍历非叶子节点 找到左右子节点较小的一个 父节点与上一步找到的最小的节点比较，如果比子节点大，则交换两个节点位置，否则回到第一步 将用于交换的子节点作为新的父节点，从第2步重新开始比较 构建最大堆与最小堆的区别第2步找到较大的一个第3步如果比子节点小则交换位置 插入/删除节点 插入节点：新插入的节点作为最后一个节点，做上浮操作 删除节点：从堆顶删除节点，将最后一个节点放到堆顶，做下沉操作 上浮/下沉代码示例 上浮操作 1234567891011private void upAdjust(int[] array) { int childIdx = array.length - 1; int parentIdx = (childIdx - 1) / 2; int temp = array[childIdx]; while (childIdx &gt; 0 &amp;&amp; temp &lt; array[parentIdx]) { array[childIdx] = array[parentIdx]; childIdx = parentIdx; parentIdx = (childIdx - 1) / 2; } array[childIdx] = temp;} 下沉操作 123456789101112131415161718192021private void downAdjust(int[] array, int parentIdx) { int len = array.length; int temp = array[parentIdx]; int childIdx = parentIdx * 2 + 1; while (childIdx &lt; len) { // 如果有右孩子，并且右孩子比左孩子小，则与右孩子交换 if (childIdx + 1 &lt; len &amp;&amp; array[childIdx + 1] &lt; array[childIdx]) { childIdx++; } if (temp &lt;= array[childIdx]) { break; } // 将左/右孩子上移 array[parentIdx] = array[childIdx]; // 孩子节点作为新的父节点 parentIdx = childIdx; // 下一个孩子节点 childIdx = parentIdx * 2 + 1; } array[parentIdx] = temp;} 优先级队列优先级队列的一种实现方式是使用最大堆 入队：新插入的节点作为最大堆的最后一个节点，然后上浮 出队：从最大堆顶删除节点 排序算法堆排序堆排序的实现方式 从排序数据构建堆，升序-&gt;最大堆，降序-&gt;最小堆 将堆顶元素与最后一个节点交换位置 新的堆顶元素下沉，下沉的界限是未排序的部分 鸡尾酒排序鸡尾酒排序与冒泡排序类似遍历的方式改为：从左往右遍历，再从右往左遍历如果某一个遍历未发生交换，则认为数据已经有序 快速排序 双边循环法 选择一个基准元素left和right两个索引分别向中间移动，和交换元素，left索引需要优先于right索引移动，否则影响下一步的交换当两个索引重合时，索引指向的元素和基准元素交换位置以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 单边循环法 以最左边元素为基准元素指定mask指针指向基准元素往右遍历，如果有比基准元素小的元素时，mask指针向右移动一位，与遍历的元素交换位置当遍历完后，mask指针指向的元素与基准元素交换以基准元素新的位置为中心，将数组拆分成两部分，分别进行快速排序 快速排序的非递归实现 将每一步产生的两段的start、end索引放入到一个栈中弹出元素遍历，将新的两段重新入栈，直至栈清空 计数排序排序方式 获取数组元素的最小和最大值以最小和最大值的距离创建一个countArray数组遍历数组，将数组元素对应countArray数组位置的值+1遍历统计数组，输出结果 缺点只能排序整数数组，如果数组含有小数则无法排序最小值和最大值差距过大是造成空间浪费 桶排序排序方式 获取数组元素的最小和最大值，得到最大值与最小值的间距d以最小和最大值的距离创建一个List的数组遍历数组，(array[i] - min) / d * (数组大小 - 1)将元素放入上一步找到的桶List中每个List内部进行排序遍历数组，输出每个List的值 缺点最小值和最大值差距过大是造成空间浪费 算法题LeetCode 377. 组合总和 Ⅳ今天算法题来自于力扣网 377. 组合总和 Ⅳ 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 123456789101112131415示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 基本思路 动态规划是每次第i+n位置加上第i位置的排列数递归法是计算每个target-n的排列数之和 代码实现 动态规划 12345678910111213141516class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; Arrays.sort(nums); dp[0] = 1; for (int i = 0; i &lt; target; i++) { for (int n : nums) { if (i + n &lt;= target) { // dp数组位置+n，既新的位置多了dp[i]种排列 dp[i + n] += dp[i]; } } } return dp[target]; }} 递归 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { if (target == 0) { return 1; } int count = 0; for (int n : nums) { if (target &gt;= n) { // target的排列数 = 每个target-n的排列数之和 count += combinationSum4(nums, target - n); } } return count; }}","link":"/2020/11/02/note-2020-11-02/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"垃圾收集","slug":"垃圾收集","link":"/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java集合","slug":"Java集合","link":"/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java线程","slug":"Java线程","link":"/tags/Java%E7%BA%BF%E7%A8%8B/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java算法","slug":"Java算法","link":"/tags/Java%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}